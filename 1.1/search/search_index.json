{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"WebGear - Composable, type-safe APIs in Haskell","text":"<p>Webgear is a framework to build HTTP APIs in Haskell. WebGear helps to run these APIs as a web application, automatically generate OpenAPI documentation, and extract other static information about the APIs in general.</p> <p>WebGear is developer-friendly. While WebGear internally uses many advanced language extensions, considerable effort is spent in exposing only a small portion of it in user APIs so that you need not be an expert to use them. It also has comprehensive documentation and examples that shortens the learning curve.</p> <p>WebGear is very flexible, allowing you to build your project the way you want. It is very easy to extend or completely replace most of the components to make it work the way you need it to.</p> <p>Learn more about WebGear and how it compares against alternatives in the user guide.</p>"},{"location":"packages/","title":"WebGear Packages","text":"<p>The following packages are available on Hackage and Stackage.</p> <ul> <li> <p>webgear-core:</p> <p>This package defines the core components of WebGear used to define APIs.</p> <ul> <li>Hackage</li> <li>Stackage</li> </ul> </li> <li> <p>webgear-server:</p> <p>This package helps to generate WAI applications based on WebGear API specifications.</p> <ul> <li>Hackage</li> <li>Stackage</li> </ul> </li> <li> <p>webgear-openapi:</p> <p>This package can be used to generate OpenAPI specifications from WebGear applications.</p> <ul> <li>Hackage</li> <li>Stackage</li> </ul> </li> <li> <p>webgear-swagger:</p> <p>This package can be used to generate Swagger 2.0 specifications from WebGear applications.</p> <ul> <li>Hackage</li> <li>Stackage</li> </ul> </li> <li> <p>webgear-swagger-ui:</p> <p>This package provides an endpoint to launch swagger-ui to browse Swagger 2.0 / OpenAPI specifications.</p> <ul> <li>Hackage</li> <li>Stackage</li> </ul> </li> </ul>"},{"location":"user-guide/architecture/handlers/","title":"Handlers","text":"<p>This chapter explains the architecture of WebGear handlers.</p>"},{"location":"user-guide/architecture/handlers/#handler-functions","title":"Handler Functions","text":"<p>Handlers are components that accept a request as input and produce a response as output. A good first intuition is that they can be represented as functions of type <code>Monad m =&gt; Request -&gt; m Response</code>. We compute the response in a monad because it typically has some side effects, such as accessing a database, logging etc.</p> <p>It is useful to represent handlers as functions because you can split the logic to as many functions as you like and compose them to form a handler. The ability to compose small, manageable pieces of code is very important to build maintainable applications.</p> <p>For example, let us consider a handler that needs to:</p> <ol> <li>Extract a query parameter from the request.</li> <li>Retrieve some data from a database using this parameter.</li> <li>Form a response based on the retrieved data.</li> </ol> <p>If there are three functions corresponding to these steps:</p> <pre><code>extractQueryParam :: Moand m =&gt; Request -&gt; m QueryParam\nextractQueryParam = ....\nretrieveDataFromDB :: Monad m =&gt; QueryParam -&gt; m DBData\nretrieveDataFromDB = ....\nmakeResponse :: Monad m =&gt; DBData -&gt; m Response\nmakeResponse = ....\n</code></pre> <p>Now you can compose these to form a handler:</p> <pre><code>handler :: Monad m =&gt; Request -&gt; m Response\nhandler = extractQueryParam &gt;=&gt; retrieveDataFromDB &gt;=&gt; makeResponse\n</code></pre> <p>However, there is one drawback to this representation. The only thing you can do with this function is to evaluate it by supplying a request. What if we want to get the name of the query parameter used or the expected HTTP status code of the response without executing the handler? This kind of information is useful to generate documentation about the handler, automatically build a client program for the API etc. Unfortunately, the monadic function representation is not suited for anything like that.</p>"},{"location":"user-guide/architecture/handlers/#handler-arrows","title":"Handler Arrows","text":"<p>The problem we face is that we need to maintain some static information about the handler that is independent of the function evaluation. WebGear uses arrows (1) to solve this problem. They support some static parts in addition to the dynamic evaluation part.</p> <ol> <li>See the arrows tutorial</li> </ol> <p>Let us look at the hello world handler from the previous chapter again:</p> <pre><code>proc request -&gt;\nrespondA HTTP.ok200 PlainText -&lt; \"Hello, World!\" :: Text\n</code></pre> <p>Here, <code>\"Hello, World!\"</code> is to the right of <code>-&lt;</code>; it is an input to the arrow. Values passed as input to arrows are known only while evaluating the handler with a request. On the other hand, <code>HTTP.ok200</code> and <code>PlainText</code> are to the left of <code>-&lt;</code> and are used to construct the arrow. Hence, they are known even without evaluating the handler.</p> <p>This separation of static and dynamic parts of the API enables WebGear to extract static information from handlers without \"executing\" them. For example, <code>webgear-openapi</code> generates OpenAPI documentation from handlers while <code>webgear-server</code> runs a handler as a WAI application.</p> <p>WebGear handlers are instances of <code>Handler</code> typeclass defined as:</p> <pre><code>class (ArrowChoice h, ArrowPlus h, ArrowError RouteMismatch h, Monad m) =&gt; Handler h m | h -&gt; m where\n-- | Lift a monadic function to a handler arrow\narrM :: (a -&gt; m b) -&gt; h a b\n....\n</code></pre> <p>Here, <code>h a b</code> is an arrow whose input is of type <code>a</code> and output is of type <code>b</code>. This is analogous to a function of type <code>a -&gt; m b</code>. An arrow of type <code>Handler h =&gt; h Request Response</code> will be able to handle HTTP requests and produce a response.</p> <p>Every handler has an underlying monad <code>m</code> in which the handler executes. You can lift a monadic computation to a handler using the <code>arrM</code> function.</p> <p>A handler is an instance of <code>ArrowChoice</code>. Thus, we can use conditionals - <code>if</code> and <code>case</code> expressions - in handler implementations. A handler also has an instance of <code>ArrowPlus</code>. This is used to implement routing - choosing one handler from many based on the request path and method.</p>"},{"location":"user-guide/architecture/handlers/#constraints","title":"Constraints","text":"<p>Type annotations on handlers can often be very verbose because you need to explicitly mention all the traits used by the handlers. WebGear has defined a few type aliases to make it as concise as possible.</p> <p>As an example, you can use this type annotation if you have a handler arrow <code>myHandler</code> that deals with a bunch of traits:</p> <pre><code>myHandler ::\n( StdHandler h m\n, HaveTraits [q1, q2, q3, ....] ts\n, Gets h [t1, t2, t3, ....] Request\n, Sets h [s1, s2, s3, ....] Response\n) =&gt;\nRequestHandler h ts\nmyHandler = proc request -&gt; do\n....\n</code></pre> <p>The <code>HaveTraits</code> constraint requires that the input request has all the traits <code>q1</code>, <code>q2</code>, <code>q3</code>, etc. witnessed by it. Typically, this is achieved by wrapping <code>myHandler</code> with some middlewares that probe for these traits. You will learn about middlewares in the next chapter.</p> <p>The <code>Gets</code> constraint declares that <code>myHandler</code> attempts to get the traits <code>t1</code>, <code>t2</code>, <code>t3</code>, etc. from the request using <code>probe</code> function.  The <code>Sets</code> constraint declared that <code>myHandler</code> attempts to set the traits <code>s1</code>, <code>s2</code>, <code>s3</code>, etc. on the response using <code>plant</code> function.</p> <p>The <code>StdHandler</code> is a shortcut to add a few common constraints which is typically used by all handlers.</p>"},{"location":"user-guide/architecture/middlewares/","title":"Middlewares","text":"<p>Middlewares are higher-order functions that enhance handlers. They accept a handler as a function argument and produce a handler as the result.</p>"},{"location":"user-guide/architecture/middlewares/#request-middlewares","title":"Request Middlewares","text":"<p>A middleware can enhance a handler by probing for traits in the request.</p> <pre><code>type RequestHandler h ts = h (Request `With` ts) Response\ntype Middleware h tsOut tsIn = RequestHandler h tsIn -&gt; RequestHandler h tsOut\n</code></pre> <p>Here is an example:</p> <pre><code>queryParam ::\n(Get h (RequiredQueryParam name val) Request, ArrowChoice h)\n=&gt; h (Request `With` ts, Either ParamNotFound ParamParseError) Response  -- ^ error handler\n-&gt; Middleware h ts (RequiredQueryParam name val : ts)\nqueryParamHandler errorHandler nextHandler = proc request -&gt; do\nresult &lt;- probe QueryParam -&lt; request\ncase result of\nLeft err -&gt; errorHandler -&lt; (request, err)\nRight val -&gt; nextHandler -&lt; val\n</code></pre> <p>This middleware chooses between <code>nextHandler</code> and <code>errorHandler</code> based on the result of probing the <code>QueryParam</code> trait. In this case, <code>nextHandler</code> has an additional trait <code>RequiredQueryParam name val</code> in its request input.</p>"},{"location":"user-guide/architecture/middlewares/#more-use-cases","title":"More Use Cases","text":"<p>Middlewares are useful because we can chain a sequence of middlewares to produce a handler as shown in this example:</p> <pre><code>jwtAuth jwk $\nqueryParam @\"limit\" @Int errorHandler $\nqueryParam @\"offset\" @Int errorHandler $\nmyHandler\n</code></pre> <p>Keep in mind that middlewares are a lot more flexible than the patterns shown above; there are many other types of transformations possible. For example, you can have a middleware that captures a correlation ID, or generate a new one and inject it as a request trait. When the underlying handler returns a response, this middleware can add a response header with the correlation ID.</p>"},{"location":"user-guide/architecture/routing/","title":"Routing","text":"<p>So far we have been using a single handler. What if we have multiple API endpoints and corresponding handlers?</p>"},{"location":"user-guide/architecture/routing/#arrowplus-typeclass","title":"ArrowPlus Typeclass","text":"<p>The ArrowPlus typeclass is used to combine multiple arrows into one. Handlers have instances of <code>ArrowPlus</code> and use this mechanism for routing. When multiple handlers are combined with <code>&lt;+&gt;</code>, they are tried from left to right till any of them successfully returns a response.</p> <p>Here is an example:</p> <pre><code>allRoutes =\n[route| POST /api/users            |] User.create\n&lt;+&gt; [route| POST /api/users/login      |] User.login\n&lt;+&gt; [route| GET  /api/users/userId:Int |] User.get\n&lt;+&gt; [route| PUT  /api/users/userId:Int |] User.update\n</code></pre> <p>A handler can indicate a routing failure by invoking the <code>routeMismatch</code> arrow. Out of the box, <code>method</code>, <code>path</code>, <code>pathVar</code>, and <code>pathEnd</code> middlewares do this when the request method or path components do not match.</p> <p>If none of the handlers match a request, an HTTP response with 404 status is returned.</p>"},{"location":"user-guide/architecture/routing/#routing-middlewares","title":"Routing Middlewares","text":"<p>There are two ways of routing a request. The simplest approach is to use a Template Haskell quasi-quoter as shown above. There are two quasi-quoters - <code>route</code> and <code>match</code>. Both of these can take either a path or a method along with a path as arguments. The <code>route</code> quasi-quoter matches the complete route from the request, while <code>match</code> matches only a prefix. More details about these can be found in the API documentation of <code>WebGear.Core.Trait.Path</code> module.</p> <p>There is an alternative, if you prefer to avoid Template Haskell. Both these quasi-quoters are implemented using middlewares that you can directly use instead:</p> <ul> <li>The <code>method</code> middleware attempts to match an HTTP method.</li> <li>The <code>path</code> middleware matches a literal path component.</li> <li>The <code>pathVar @\"varName\" @t</code> middleware will try to capture the next path component as a variable with the name   <code>varName</code> and convert it to a value of type <code>t</code>.</li> <li>Finally, <code>pathEnd</code> will try to ensure that no more path components remain to be matched in the request.</li> <li>All these middlewares will invoke <code>routeMismatch</code> on failure.</li> </ul> <p>For example, <code>[route| GET /api/users/userId:Int |] User.get</code> can be written as:</p> <pre><code>method GET $ path \"/api/users\" $ pathVar @\"userId\" @Int $ pathEnd $ User.get\n</code></pre> <p>And <code>[match| GET /api/users/userId:Int |] User.get</code> translates to:</p> <pre><code>method GET $ path \"/api/users\" $ pathVar @\"userId\" @Int $ User.get\n</code></pre>"},{"location":"user-guide/architecture/traits/","title":"Traits","text":"<p>Traits are a fundamental concept in WebGear that enables type-safety in APIs and many other elements make use of it one way or another. So let us explore it first.</p>"},{"location":"user-guide/architecture/traits/#motivation","title":"Motivation","text":"<p>Most APIs handlers retrieve some information from the request and process it. For example, consider an endpoint that expects a JSON formatted request body. The body may not be present in the request, in which case we need to perform some error handling. We might have many endpoints that share the same error handling logic. So it is useful if we could build our handlers such that:</p> <ul> <li>The request handler only has to deal with the cases where all required information is guaranteed to be present.</li> <li>The error handler only has to deal with the cases where the required information is absent.</li> <li>The type system ensures that we cannot accidentally invoke the wrong handler in both these cases.</li> </ul> <p>Traits are a mechanism to achieve this.</p>"},{"location":"user-guide/architecture/traits/#basics","title":"Basics","text":"<p>Traits are optional attributes associated with a value. For example, the JSON formatted body mentioned above is a trait associated with the request value. In WebGear, it is represented by the type <code>Body JSON b</code> - the request body is parsed into a value of type <code>b</code>.</p> <p>A trait might be associated with many types of values. For example, the <code>Body JSON b</code> trait is associated with both <code>Request</code> and <code>Response</code> types because both may contain a body.</p> <p>Traits have instances of these typeclasses:</p> <pre><code>-- Indicates that `t' is contained in `a'\nclass Trait t a where\n-- Type of trait value\ntype Attribute t a :: Type\nclass Trait t a =&gt; TraitAbsence t a where\n-- An error indicator when the trait is missing\ntype Absence t a :: Type\n</code></pre> <p>Instances for <code>Body JSON b</code> are: (1)</p> <ol> <li>This is a simplified example. The actual definitions of these instances is more general.</li> </ol> <pre><code>instance Trait (Body JSON b) Request where\ntype Attribute (Body JSON b) Request = b\ninstance TraitAbsence (Body JSON b) Request where\ntype Absence (Body JSON b) Request = Text\n</code></pre> <p>Here, <code>Attribute (Body JSON b) Request</code> is <code>b</code> because we get a value of type <code>b</code> when we successfully parse the JSON body. <code>Absence (Body JSON b) Request</code> is <code>Text</code> because that is the type of error we get when the request body is parsed.</p>"},{"location":"user-guide/architecture/traits/#witnessed-values","title":"Witnessed Values","text":"<p>The next step is to associate traits with values. We get a value of type <code>Request `With` '[Body JSON b]</code> if we associate the <code>Body JSON b</code> type with <code>Request</code>. We can associate more than one trait - e.g. <code>t1</code>, <code>t2</code>, <code>t3</code>, ... - in which case we'll have a value of type <code>Request `With` '[t1, t2, t3]</code> (1) . These are called witnessed values.</p> <ol> <li>See the DataKinds section in Language Extensions chapter.</li> </ol> <p>But what does it mean to have a witnessed value? A witness is a proof that the specified traits exist in the value. If you have a <code>Request `With` '[Body JSON b]</code> value, you have a guarantee that it contains a JSON formatted <code>b</code> value. You can access the trait attribute from a witnessed value thus:</p> <pre><code>request :: Request `With` '[Body JSON b]\nrequest = ....\nlet body :: b\nbody = pick @(Body JSON b) $ from request\n</code></pre> <p>You don't need to handle the case of missing JSON body if you have a witnessed request.</p> <p>How do we produce a witnessed value? After all, we need to have a check somewhere that the body is actually present. This is done with the <code>probe</code> function.</p> <pre><code>probe :: Get h t a =&gt; t -&gt; h (a `With` ts) (Either (Absence t a) (a `With` (t : ts)))\n</code></pre> <p>This function gives us an arrow (1) that takes a witnessed value - <code>a `With` ts</code> - as input and returns another witnessed value - <code>a `With` (t:ts)</code> - on success or an <code>Absence t a</code> value on failure to retrieve the <code>t</code> trait. The resultant witnessed value has a <code>t</code> trait in addition to the traits in the original request.</p> <ol> <li>See arrows tutorial</li> </ol> <p>We can chain many invocations of <code>probe</code> for many traits, accumulating all those traits in the <code>ts</code> type-level list. The final witnessed value will have all those traits. And we can invoke <code>pick @t $ from request</code> for any trait as long as it is present in the <code>ts</code> list.</p>"},{"location":"user-guide/architecture/traits/#getting-traits","title":"Getting Traits","text":"<p>A trait has to implement the <code>Get</code> typeclass for the <code>probe</code> function to work:</p> <pre><code>class (Arrow h, TraitAbsence t a) =&gt; Get h t a where\ngetTrait :: t -&gt; h (a `With` ts) (Either (Absence t a) (Attribute t a))\n</code></pre> <p>The <code>getTrait</code> should attempt to retrieve the trait attribute or return an <code>Absence</code> value to indicate failure.</p> <p>You can build your own traits by providing instances of <code>Trait</code>, <code>TraitAbsence</code>, and <code>Get</code>.</p>"},{"location":"user-guide/architecture/traits/#setting-traits","title":"Setting Traits","text":"<p>Everything we discussed so far was to retrieve traits from requests. A similar implementation exists for setting traits on responses as well. The <code>Set</code> typeclass exists for this purpose:</p> <pre><code>class (Arrow h, Trait t a) =&gt; Set h t a where\n-- | Set a trait attribute @t@ on the value @a@.\nsetTrait ::\n-- | The trait to set\nt -&gt;\n-- | A function to generate a witnessed value. This function must be\n-- called by the `setTrait` implementation to generate a witnessed\n-- value.\n(a `With` ts -&gt; a -&gt; Attribute t a -&gt; a `With` (t : ts)) -&gt;\n-- | An arrow that attches a new trait attribute to a value witnessed\n-- with other traits\nh (a `With` ts, Attribute t a) (a `With` (t : ts))\n</code></pre> <p>You can use the <code>plant</code> function to set a trait attribute on a witnessed value. This is the counterpart of <code>probe</code>.</p> <pre><code>plant :: Set h t a =&gt; t -&gt; h (a `With` ts, Attribute t a) (a `With` (t : ts))\n</code></pre> <p>This function gives you an arrow that takes a witnessed value - <code>a `With` ts</code> and a trait attribute as inputs and returns another witnessed value - <code>a `With` (t:ts)</code> - as the result. This result has an additional trait - <code>t</code> - on it.</p>"},{"location":"user-guide/architecture/traits/#final-points","title":"Final Points","text":"<p>You have seen how traits help to build witnessed values, which then can be used to access the trait attributes in a type-safe fashion. But they look like just getters and setters, why do we even need them?</p> <p>The differentiating factor is that the <code>Get</code> and <code>Set</code> typeclasses also depend on the arrow in which they operate. This allows us to have different implementations for the same trait depending on the arrow. For example, there is an implementation of <code>Body JSON</code> for the <code>ServerHandler</code> arrow and a completely different one for the <code>OpenApiHandler</code> arrow. The former one implements a server that retrieves a body from the request, while the latter generates OpenAPI documentation for the body.</p> <p>In addition to the core traits provided by WebGear, you can have your own traits by implementing the typeclasses mentioned in this chapter. These traits will be as first class as the WebGear traits.</p>"},{"location":"user-guide/common-tasks/authentication/","title":"Authentication","text":"<p>WebGear has first class support for common authentication schemes and mechanisms to implement any custom authentication schemes you need. Let us explore these.</p>"},{"location":"user-guide/common-tasks/authentication/#basic-authentication","title":"Basic Authentication","text":"<p>Typical usage of basic authentication is:</p> <pre><code>{-\n * The credentials are validated in the IO monad.\n * A `Username' is extracted on success and a `Text' error message on failure.\n-}\ntype UserAuth = BasicAuth IO Text Username\nhelloHandler ::\n( StdHandler h IO,\n, Get h UserAuth Request\n, Sets h [RequiredResponseHeader \"Content-Type\" Text, Body PlainText String] Response\n) =&gt;\nRequestHandler h '[]\nhelloHandler =\nbasicAuth authConfig authFail $\nproc request -&gt; do\nlet username = pick @UserAuth $ from request\nmsg = \"Hello, \" &lt;&gt; show username &lt;&gt; \"!\"\nrespondA HTTP.ok200 PlainText -&lt; msg\n-- Send a response when authentication fails\nauthFail ::\n( StdHandler h IO\n, Sets h [RequiredResponseHeader \"Content-Type\" Text, Body PlainText String] Response\n) =&gt;\nh (Request `With` ts, BasicAuthError Text) Response\nauthFail = proc (_request, err) -&gt;\nrespondA HTTP.forbidden403 PlainText -&lt; show err\n-- This is where you validate the credentials\nauthConfig :: UserAuth\nauthConfig = BasicAuth'{ .... }\n</code></pre> <p>The <code>authFail</code> handler comes into play when authentication fails. That is, either credentials are missing in the request, or cannot be formatted, or fails the validation specified in <code>authConfig</code>.</p> <p>Basic authentication support is not limited to this. There are more middlewares in the <code>WebGear.Core.Trait.Auth.Basic</code> module that allows custom authentication schemes instead of the standard <code>Basic</code> scheme. They also support optional authentication where the credentials may not always be present in the request.</p>"},{"location":"user-guide/common-tasks/authentication/#jwt-authentication","title":"JWT Authentication","text":"<p>JWT authentication with a bearer token is similar to basic authentication:</p> <pre><code>type UserAuth = JWTAuth IO Text Username\nhelloHandler ::\n( StdHandler h IO\n, Get h UserAuth Request\n, Sets h [RequiredResponseHeader \"Content-Type\" Text, Body PlainText String] Response\n) =&gt;\nRequestHandler h '[]\nhelloHandler =\njwtAuth authConfig authFail $\nproc request -&gt; do\nlet username = pick @UserAuth $ from request\nmsg = \"Hello, \" &lt;&gt; show username &lt;&gt; \"!\"\nrespondA HTTP.ok200 PlainText -&lt; msg\n-- Configuration to validate JWT\nauthConfig :: UserAuth\nauthConfig =\nJWTAuth'\n{ jwtValidationSettings = ....\n, jwkSet = ....\n, toJWTAttribute = ....\n}\n</code></pre> <p>Similar to basic authentication, more middlewares are available in the <code>WebGear.Core.Trait.Auth.JWT</code> module.</p>"},{"location":"user-guide/common-tasks/authentication/#custom-authentication","title":"Custom Authentication","text":"<p>WebGear supports custom authentication requirements if your application needs it. Here is how you build it:</p> <ol> <li>Define a trait <code>t</code> for the authentication scheme. Implement <code>Trait</code> and <code>TraitAbsence</code> instances for this trait.</li> <li>Implement a <code>Get h t Request</code> typeclass instance for every handler <code>h</code> that you intend to support.</li> <li>Implement middlewares that <code>probe</code> for the newly defined trait.</li> </ol> <p>That's all! The middlewares are now ready for use in your handlers.</p>"},{"location":"user-guide/common-tasks/generating-responses/","title":"Generating Responses","text":"<p>WebGear has a number of middlewares and functions to generate responses. We'll explore them in this chapter.</p>"},{"location":"user-guide/common-tasks/generating-responses/#basic-response-generation","title":"Basic Response Generation","text":"<p>The easiest way to generate responses is using the <code>respondA</code> arrow. For example, to generate a plain text response with HTTP status 200:</p> <pre><code>import qualified Network.HTTP.Types as HTTP\nrespondA HTTP.ok200 PlainText -&lt; \"A response body\" :: Text\n</code></pre> <p>For generating JSON responses:</p> <pre><code>data Person = Person { name :: Text, email :: Text }\nderiving (Generic, ToJSON)\nlet person :: Person\nperson = Person \"John Smith\" \"john@smith.com\"\nrespondA HTTP.ok200 JSON -&lt; person\n</code></pre>"},{"location":"user-guide/common-tasks/generating-responses/#advanced-response-generation","title":"Advanced Response Generation","text":"<p>You can get finer control over the response using a few additional control structures.</p> <p>The <code>mkResponse</code> arrow generates a response with a specific HTTP status code.</p> <pre><code>-- resp :: Response `With` '[Status]\nresp &lt;- mkResponse HTTP.ok200 -&lt; ()\n</code></pre> <p>There are helper arrows in the <code>WebGear.Core.Trait.Status</code> module that generates responses for all standard HTTP status codes.</p> <p><code>setBody</code> can add a body to a response. For example:</p> <pre><code>(ok200 -&lt; ())\n&gt;-&gt; (\\resp -&gt; setBody PlainText -&lt; (response, \"Hello, World!\" :: Text))\n</code></pre> <p><code>setHeader</code> adds a header value to a response:</p> <pre><code>(ok200 -&lt; ())\n&gt;-&gt; (\\resp -&gt; setHeader @\"Cache-Control\" @Text -&lt; (resp, \"no-cache\"))\n</code></pre>"},{"location":"user-guide/common-tasks/handling-requests/","title":"Handling Requests","text":"<p>We learned about the core architecture components in the previous chapters. Now, let us use them to extract information from requests.</p>"},{"location":"user-guide/common-tasks/handling-requests/#query-parameters","title":"Query Parameters","text":"<p>If you expect a query parameter in your handler, use the <code>queryParam</code> middleware:</p> <pre><code>myHandler ::\n( StdHandler h m\n, Get h (RequiredQueryParam \"limit\" Integer) Request\n, Sets h [RequiredResponseHeader \"Content-Type\" Text, Body PlainText String] Response\n) =&gt;\nRequestHandler h ts\nmyHandler =\nqueryParam @\"limit\" @Integer errorHandler $\nproc request -&gt; do\nlet limit :: Integer\nlimit = pick @(RequiredQueryParam \"limit\" Integer) $ from request\n....\nerrorHandler ::\n( StdHandler h m\n, Sets h [RequiredResponseHeader \"Content-Type\" Text, Body PlainText String] Response\n) =&gt;\nh (Request `With` ts, Either ParamNotFound ParamParseError) Response\nerrorHandler = proc (_, err) -&gt; respondA HTTP.badRequest400 PlainText -&lt; show err\n</code></pre> <p>If the query parameter is missing or invalid, the <code>errorHandler</code> will be invoked to generate a response. There is also an <code>optionalQueryParam</code> middleware that can be used when the query parameter is not required.</p>"},{"location":"user-guide/common-tasks/handling-requests/#header-values","title":"Header Values","text":"<p>Extracting header values from a request is very similar to query parameters:</p> <pre><code>-- Some type representing the ETag header value\ndata ETag = ....\n-- This instance is used to parse the ETag value\ninstance FromHttpApiData ETag where\n....\nmyHandler ::\n( StdHandler h m\n, Get h (RequiredRequestHeader \"If-Match\" ETag) Request\n) =&gt;\nRequestHandler h ts\nmyHandler =\nheader @\"If-Match\" @ETag errorHandler $\nproc request -&gt; do\nlet etag :: ETag\netag = pick @(RequiredRequestHeader \"If-Match\" ETag) $ from request\n....\n</code></pre>"},{"location":"user-guide/common-tasks/handling-requests/#body","title":"Body","text":"<p>You can parse the request body to a Haskell value using the <code>requestBody</code> middleware:</p> <pre><code>-- Some type representing a PNG image\ndata PNGImage = ....\n-- This instance is used to parse the body\ninstance FromByteString PNGImage where\n....\nmyHandler ::\n( StdHandler h m\n, Get h (Body OctetStream PNGImage) Request\n) =&gt;\nRequestHandler h ts\nmyHandler =\nrequestBody @PNGImage OctetStream errorHandler $\nproc request -&gt; do\nlet img :: PNGImage\nimg = pick @(Body OctetStream PNGImage) $ from request\n....\n</code></pre> <p>Use the <code>jsonRequestBody</code> middleware to parse a JSON  request body:</p> <pre><code>data Person = ....\n-- This instance is used to parse the body\ninstance FromJSON Person where\n....\nmyHandler ::\n( StdHandler h m\n, Get h (Body JSON Person) Request\n) =&gt;\nRequestHandler h ts\nmyHandler =\nrequestBody @Person JSON errorHandler $\nproc request -&gt; do\nlet person :: Person\nperson = pick @(Body JSON Person) $ from request\n....\n</code></pre>"},{"location":"user-guide/common-tasks/handling-requests/#conclusion","title":"Conclusion","text":"<p>We covered a few common use cases above, but many others are supported by WebGear. See modules under <code>WebGear.Core.Trait</code> for details.</p>"},{"location":"user-guide/first-steps/getting-started/","title":"Getting Started","text":""},{"location":"user-guide/first-steps/getting-started/#prerequisites","title":"Prerequisites","text":"<p>This guide teaches you to use WebGear effectively. However, there are some things you should learn before using WebGear.</p>"},{"location":"user-guide/first-steps/getting-started/#haskell","title":"Haskell","text":"<p>WebGear requires that you have a decent understanding of Haskell programming language. You must have a good grasp of typeclasses, functors, and monads. You should also be familiar with some commonly used GHC extensions such as <code>MultiParamTypeClasses</code>, <code>OverloadedStrings</code>, <code>TypeApplications</code> etc.</p> <p>WebGear uses few other GHC extensions. This guide includes material to teach you those features.</p>"},{"location":"user-guide/first-steps/getting-started/#ghc-requirements","title":"GHC Requirements","text":"<p>WebGear 1.1.0 supports GHC versions from <code>8.10</code> till <code>9.6</code>. While other versions are untested and unsupported, you can try them on your own.</p>"},{"location":"user-guide/first-steps/getting-started/#build-tools","title":"Build Tools","text":"<p>WebGear will work with both Cabal and Stack. This guide assumes you already know how to use these tools.</p>"},{"location":"user-guide/first-steps/getting-started/#getting-help","title":"Getting help","text":"<p>If you run into issues, see the troubleshooting section first. You can report bugs and request features in the GitHub repo.</p>"},{"location":"user-guide/first-steps/hello-world/","title":"Hello, World!","text":""},{"location":"user-guide/first-steps/hello-world/#first-application","title":"First Application","text":"<p>Let us build our first application with WebGear. Create a new project with three files as shown below.</p> Main.hshello.cabalstack.yaml <pre><code>{-# LANGUAGE Arrows #-}\n{-# LANGUAGE OverloadedStrings #-}\nmodule Main where\nimport qualified Network.HTTP.Types as HTTP\nimport qualified Network.Wai.Handler.Warp as Warp\nimport WebGear.Server\nmain :: IO ()\nmain =\nWarp.run 3000 $ toApplication $\nmethod HTTP.GET $\npath \"/api/hello\" $\nproc request -&gt;\nrespondA HTTP.ok200 PlainText -&lt; \"Hello, World!\" :: Text\n</code></pre> <pre><code>cabal-version:      2.4\nname:               hello\nversion:            0.1.0.0\n\nexecutable hello\n    main-is:          Main.hs\n    build-depends:    base &gt;=4.13.0.0 &amp;&amp; &lt;4.19\n                    , http-types ==0.12.*\n                    , warp ==3.3.*\n                    , webgear-core ==1.1.0\n                    , webgear-server ==1.1.0\n    default-language: Haskell2010\n</code></pre> <pre><code>resolver: nightly-2023-12-25\nallow-newer: true\n</code></pre> <p>You can omit stack.yaml if you are not using stack.</p>"},{"location":"user-guide/first-steps/hello-world/#running-the-server","title":"Running the Server","text":"<p>Compile this program with Stack or Cabal and run it. Access the URL http://localhost:3000/api/hello and you should be greeted with a message <code>Hello, World!</code>.</p>"},{"location":"user-guide/first-steps/hello-world/#exploring-the-code","title":"Exploring the code","text":"<p>Here is an explanation of how the above code works:</p> <ol> <li>The <code>method HTTP.GET</code> function indicates that this API accepts only GET requests.</li> <li>The <code>path \"/api/hello\"</code> function matches a specific request path, any request that does not match this path will    result in a 404 response.</li> <li>The <code>proc</code> notation is special syntax introduced by arrows. You should read the arrows chapter if you are not    familiar with it.</li> <li>Finally, <code>respondA</code> is used to send a <code>text/plain</code> response with a body.</li> <li>The <code>toApplication</code> converts its argument to a WAI application. This    application is run as a Warp server using <code>Warp.run</code>.</li> </ol> <p>We will see more details about all these in the upcoming chapters.</p>"},{"location":"user-guide/first-steps/introduction/","title":"Introduction","text":""},{"location":"user-guide/first-steps/introduction/#what-is-webgear","title":"What is WebGear?","text":"<p>WebGear is a high-performance framework to build composable, type-safe HTTP APIs. It is designed to make common API development tasks easy. It is also easily extensible to add components needed by your project.</p>"},{"location":"user-guide/first-steps/introduction/#why-use-webgear","title":"Why use WebGear?","text":"<p>If you are already familiar with other Haskell web frameworks, you might be interested in how WebGear compares against them. This section compares WebGear against some popular frameworks to give you an idea of why it is useful.</p>"},{"location":"user-guide/first-steps/introduction/#servant","title":"Servant","text":"<p>Servant uses advanced type level combinators to express API components, while WebGear has traits which are regular data types combined with a few type class instances. Most of the differences between WebGear and Servant stem from this. Note that WebGear do use type-level lists of traits for building type-safe APIs. But that is a fairly limited usage of type-level programming and is easier to learn.</p> <ul> <li>Programming at type level is more verbose and require knowledge of advanced extensions. This is avoided in WebGear by   doing most of the operations at value level instead of type level.</li> <li>Some type-level structures are not as composable as regular values. For example, a package like   servant-flatten is needed to factor out combinators. WebGear does not   have this problem, simply because it uses function calls and function composition to express APIs.</li> <li>It is hard to express certain ideas at type-level. For example, basic authentication support in Servant requires a   <code>Context</code> that specifies a function to validate credentials. It is required to use this ad-hoc approach because   Servant combinators are at type level and cannot include a function. On the other hand, WebGear traits can include   functions in them because they are values.</li> <li>Servant is a very popular project with a large ecosystem of companion packages. WebGear is a younger project, and may   not support such a wide variety of functionality.</li> </ul>"},{"location":"user-guide/first-steps/introduction/#ihp","title":"IHP","text":"<p>IHP is an opinionated full-stack framework for rapid application development. You can build everything from the DB schema to UI with IHP. It can significantly reduce the development time by using standardized steps to build various components. However, it may not be suitable for your specific use case and constraints. For example, IHP requires the use of Nix, and PostgreSQL is the only supported database. Your applications may not always be compatible with such constraints.</p> <p>WebGear does not aim to be a full-stack framework. It focuses on doing one thing well - building APIs. You are free to choose a UI framework, a persistence backend, build tool as your project demands.</p>"},{"location":"user-guide/first-steps/introduction/#scotty","title":"Scotty","text":"<p>Scotty is a minimalist framework to build web applications. It is trivial to build simple web applications in Scotty, but it does not support many of the WebGear features such as type-safety provided by traits, ability to build reusable components, automatic generation of OpenAPI documentation etc.</p>"},{"location":"user-guide/first-steps/introduction/#other-differences","title":"Other Differences","text":"<p>WebGear uses arrows and monads to build APIs, while other frameworks only use monads. This means there is one additional thing to learn if you are not familiar with arrows. However, this cost is justified as arrows can express API specifications at value level instead of type level. Arrows and their <code>proc</code> notation can be learned relatively easily as a natural extension of monadic computation. This guide includes an arrow tutorial to help you if you are unfamiliar with arrows.</p>"},{"location":"user-guide/reference/arrows-tutorial/","title":"Arrows Tutorial","text":"<p>Arrows - like monads - are an abstraction to represent computations with a context. However, they can express contexts that are not possible with monads.</p> <p>WebGear makes extensive use of arrows to build APIs, hence it is important that you have a good grasp of them to effectively use WebGear.</p>"},{"location":"user-guide/reference/arrows-tutorial/#basics","title":"Basics","text":"<p>Intuitively, arrows are similar to functions. Like functions, arrows have kind <code>Type -&gt; Type -&gt; Type</code>. That is, they take an input and an output type arguments. Throughout this chapter, we'll use the type variable <code>h</code> to indicate an arrow. Hence, <code>h a b</code> is an arrow with <code>a</code> as the input type and <code>b</code> as the output type.</p> <p>One significant similarity of arrows and functions is that both are composable. Arrows have Category as a superclass. Category is defined as:</p> <pre><code>class Category cat where\nid :: cat a a                         -- The identity arrow\n(.) :: cat b c -&gt; cat a b -&gt; cat a c  -- Associative composition\n</code></pre> <p>You are probably already familiar with <code>id</code> and <code>(.)</code> as identity function and function composition. <code>Category</code> is a generalization of these, it represents all types that can be composed like functions.</p> <p>There are two composition operators that make the direction of composition explicit:</p> <pre><code>-- Right to left composition\n(&lt;&lt;&lt;) :: Category cat =&gt; cat b c -&gt; cat a b -&gt; cat a c\n-- Left to right composition\n(&gt;&gt;&gt;) :: Category cat =&gt; cat a b -&gt; cat b c -&gt; cat a c\n</code></pre> <p>The <code>Arrow</code> type class is defined as:</p> <pre><code>class Category h =&gt; Arrow h where\n-- convert a function to an arrow\narr :: (a -&gt; b) -&gt; h a b\n-- map over the input type\nfirst :: h a b -&gt; h (a, c) (b, c)\n-- map over the output type\nsecond :: h a b -&gt; h (c, a) (c, b)\n--- combine two arrows\n(***) :: h a b -&gt; h c d -&gt; h (a, c) (b, d)\n(&amp;&amp;&amp;) :: h a b -&gt; h a c -&gt; h a (b, c)\n</code></pre> <p>These methods allow us to operate on multiple inputs and/or outputs represented as pairs in a single computation.</p> <p>Note that all operations you saw above manipulate and compose arrows in various ways to produce other arrows. But none of them allow you to \"execute\" an arrow - i.e. provide an input to an arrow and get an output. This is not part of the <code>Arrow</code> interface, but a specific arrow type might have such a mechanism.</p> <p>This is similar to the monad interface. The <code>Monad</code> typeclass defines a <code>return</code> method to lift a value into monadic context and <code>&gt;&gt;=</code> to bind two monadic computations. But there is no method to extract a value from a monadic context. Specific monads (for e.g., <code>Maybe</code>, <code>Either</code>, etc.) might provide some mechanism to extract a value from a monad. But it is not possible with many other monads (for e.g., <code>IO</code>, <code>Const</code>, etc.).</p> <p>In WebGear, you would compose handler arrows to form a single handler. The <code>ServerHandler</code> type allows you to provide a <code>Request</code> as input to this arrow and get a <code>Response</code> as output. This is how <code>webgear-server</code> package implements its API servers. The <code>OpenApiHandler</code> from <code>webgear-openapi</code> package do not have any mechanisms to run a server. Instead, it can extract static information about the APIs to generate OpenAPI documentation.</p>"},{"location":"user-guide/reference/arrows-tutorial/#conditionals","title":"Conditionals","text":"<p>The <code>Arrow</code> typeclass is not expressive enough to build APIs. We often need to conditionally perform actions in a handler. This is where <code>ArrowChoice</code> typeclass comes in:</p> <pre><code>class Arrow h =&gt; ArrowChoice h where\nleft  :: h a b -&gt; h (Either a c) (Either b c)          -- maps over left option\nright :: h a b -&gt; h (Either c a) (Either c b)          -- maps over right option\n(+++) :: h a c -&gt; h b d -&gt; h (Either a b) (Either c d) -- maps over both left and right\n(|||) :: h a c -&gt; h b c -&gt; h (Either a b) c            -- (+++), then merge results\n</code></pre> <p>These arrows operate on <code>Either</code> values and choose different arrows to handle <code>Left</code> and <code>Right</code> cases.</p> <p>In WebGear, <code>ArrowChoice</code> interface is used to generate different responses based on request traits. For example, if a handle requires a query parameter, we want to generate a 404 response when it is missing. Thus, we need two different handlers - one for the case where we have the query parameter in the request and another one where we don't. The <code>|||</code> operator achieves this by producing an arrow that takes an <code>Either a b</code> value as input and invoking one of the two handlers based on the input.</p>"},{"location":"user-guide/reference/arrows-tutorial/#monoid-operations","title":"Monoid Operations","text":"<p>There are cases where we want to combine multiple arrows to form a single arrow. Some arrows support this operation with <code>ArrowZero</code> and <code>ArrowPlus</code> typeclasses.</p> <pre><code>class Arrow h =&gt; ArrowZero h where\nzeroArrow :: h a b\nclass ArrowZero h =&gt; ArrowPlus h where\n(&lt;+&gt;) :: h a b -&gt; h a b -&gt; h a b\n</code></pre> <p>Notice the similarity of these classes to <code>Semigroup</code> and <code>Monoid</code> respectively. They define an associative binary operation to combine two arrows and also a <code>zeroArrow</code> that acts as an identity for the <code>&lt;+&gt;</code> operation. In other words, for any arrow <code>h</code>, you have <code>h &lt;+&gt; zeroArrow = h</code> and <code>zeroArrow &lt;+&gt; h = h</code>.</p> <p>In WebGear, these typeclasses are used to implement routing. The <code>zeroArrow</code> is a handler that always fails, indicating a route mismatch so that other handlers can be tried. In case of <code>f &lt;+&gt; g</code>, the <code>f</code> handler is tried first to get a response. If that fails to match the route, the <code>g</code> handler will be tried next.</p>"},{"location":"user-guide/reference/arrows-tutorial/#the-proc-notation","title":"The proc Notation","text":"<p>The arrow combinators are cumbersome to program with in practice. For example, consider this code:</p> <pre><code>squareA :: Arrow h =&gt; h Int Int\nsquareA = arr (\\x -&gt; x * x)\npythagorasA :: Arrow h =&gt; h (Int, Int) Int\npythagorasA = (squareA *** squareA) &gt;&gt;&gt; arr (uncurry (+))\n</code></pre> <p>It isn't immediately obvious what <code>pythagorasA</code> is trying to do. It'll help if we had some notation to add extra variable names for intermediate values. That is where <code>proc</code> notation comes in. This syntax is enabled by the <code>Arrows</code> language extension. The above program can be written with proc notation as:</p> <pre><code>squareA :: Arrow h =&gt; h Int Int\nsquareA = proc x -&gt;\nreturnA -&lt; x * x\npythagorasA :: Arrow h =&gt; h (Int, Int) Int\npythagorasA = proc (x, y) -&gt; do\nxSquare &lt;- squareA -&lt; x\nySquare &lt;- squareA -&lt; y\nreturnA -&lt; xSquare + ySquare\n</code></pre> <p>The proc notation is similar to the monadic do notation. The main difference is that an arrow has both an input and output components, unlike monad which only has one.</p> <p>The proc block starts with the <code>proc</code> keyword followed by a pattern representing the input to this arrow. For example, the <code>pythagorasA</code> arrow has <code>(x, y)</code> as its input. </p> <p>The body of the arrow notation is called a command. There are a few possible ways to write a command. In the above code, <code>squareA</code> has a single command <code>returnA -&lt; x * x</code> as its body. This means <code>x * x</code> is sent as input to <code>returnA</code> and its output is the output of <code>squareA</code>. <code>returnA</code> is the identity arrow, so effectively <code>squareA</code> returns the square of its input.</p> <p>In general, this has the form <code>aexp -&lt; iexp</code> where <code>aexp</code> is an expression evaluating to an arrow and <code>iexp</code> is an expression evaluating to its input.</p> <p>More complex arrows - such as <code>pythagorasA</code> - use a do block. In the first line <code>xSquare &lt;- squareA -&lt; x</code>, the value <code>x</code> is input to the arrow <code>squareA</code> and the result is <code>xSquare</code>. The final line feeds <code>xSquare + ySquare</code> to <code>returnA</code> which produces the result of <code>pythagorasA</code>.</p> <p>There are a few restrictions on what you can do with this notation. Firstly, the part to the left of <code>&lt;-</code> is a pattern just like the monadic do notation.</p> <p>Secondly, the expression between <code>&lt;-</code> and <code>-&lt;</code> must be an arrow. This expression cannot use any of the variables bound in the proc notation. For example, the code below is invalid because the <code>x</code> is bound as a result in first line and is used as part of the arrow expression in second line.</p> <pre><code>proc a -&gt; do\nx &lt;- foo -&lt; a\ny &lt;- bar x -&lt; a\n....\n</code></pre> <p>Arrows do not let you choose the next arrow to use based on some intermediate result from a previous arrow.(1) Bound variables such as <code>x</code> and <code>y</code> can only be used as an input to other arrows (i.e. on the right side of <code>-&lt;</code>).</p> <ol> <li><code>ArrowApply</code> typeclass allows this. But such arrows are equivalent to monads and you are better off using monads in     that case.</li> </ol> <p>The proc notation also supports <code>if</code> and <code>case</code> in commands. These require an instance of <code>ArrowChoice</code>:</p> <pre><code>factorialA :: ArrowChoice h =&gt; h Int Int\nfactorialA = proc n -&gt;\nif n == 0\nthen returnA -&lt; 1\nelse do\nres &lt;- factorialA -&lt; n - 1\nreturnA -&lt; n * res\ndata Result = Found [Pet] | NotFound\nsearchPets :: ArrowChoice h =&gt; h Name Result\nsearchPets = proc name -&gt; do\npets &lt;- fetchPetsFromDB -&lt; name\ncase pets of\n[] -&gt; returnA -&lt; NotFound\nps -&gt; returnA -&lt; Found ps\n</code></pre>"},{"location":"user-guide/reference/arrows-tutorial/#summary","title":"Summary","text":"<p>Arrows let us build composable programs. You can compose many arrows in multiple ways to produce a resultant arrow, and then in the next step run that arrow. The clean separation between these two steps help WebGear to retain static information about APIs as well as run it as a server.</p> <p>See these resources for more information about arrows:</p> <ol> <li>The Haskell wikibook has a chapter on arrows.</li> <li>Haskell wiki has an arrow tutorial.</li> <li>These two papers introduce arrows from first principles and are easy to read:</li> <li>Generalising Monads to Arrows</li> <li>Programming with Arrows</li> </ol>"},{"location":"user-guide/reference/language-extensions/","title":"Language Extensions","text":"<p>This chapter has a quick summary of some of the advanced extensions that WebGear makes use of. The GHC User's Guide has more information on these extensions.</p>"},{"location":"user-guide/reference/language-extensions/#arrows","title":"Arrows","text":"<p>This extension enables the <code>proc</code> notation for arrows. The arrows tutorial explains this notation in detail.</p>"},{"location":"user-guide/reference/language-extensions/#datakinds","title":"DataKinds","text":"<p>This extension promotes data types to kind level and enables literals at type level. For example, the <code>QueryParam</code> trait is defined as:</p> <pre><code>import GHC.TypeLits (Symbol)\ndata Existence = Required | Optional\ndata ParseStyle = Strict | Lenient\ndata QueryParam (e :: Existence) (p :: ParseStyle) (name :: Symbol) (val :: Type) = QueryParam\n</code></pre> <p>This lets us write types such as <code>QueryParam Required Strict \"offset\" Integer</code>. The data constructors <code>Required</code> and <code>Strict</code> got promoted to a type, and the types <code>Existence</code> and <code>ParseStyle</code> got promoted to kinds. This also allows string literals such as <code>\"offset\"</code> as a type.</p> <p>This extension also allows using lists at the type level. For example, types such as <code>Response ``With`` [RequiredResponseHeader \"Content-Type\" Text, Body JSON ErrorResponse]</code> is possible because of this extension.</p>"},{"location":"user-guide/reference/language-extensions/#typeapplications","title":"TypeApplications","text":"<p>WebGear uses this extension to explicitly mention values of type variables in some cases. For example, to extract a trait attribute from a witnessed request:</p> <pre><code>let maybeAuthor :: Maybe Text\nmaybeAuthor = pick @(OptionalQueryParam \"author\" Text) $ from request\n</code></pre> <p>The <code>@(OptionalQueryParam \"author\" Text)</code> type application specifies the trait to retrieve.</p>"},{"location":"user-guide/reference/language-extensions/#quasiquotes","title":"QuasiQuotes","text":"<p>This extension enables the Template Haskell quasi-quotation syntax. WebGear uses this syntax to enable routing middlewares such as <code>route</code> and <code>match</code>. Their usage is described in the Routing chapter.</p> <p>Usage of this extension is optional. You can implement equivalent functionality without using Template Haskell at the cost of some verbose code.</p>"},{"location":"user-guide/reference/troubleshooting/","title":"Troubleshooting","text":"<p>Here are some common compiler errors you might encounter and suggested solutions for them while using WebGear.</p>"},{"location":"user-guide/reference/troubleshooting/#missing-trait-constraints","title":"Missing Trait Constraints","text":"<pre><code>Could not deduce (Get h (RequiredQueryParam \"tag\" Text) Request)\n     arising from a use of \u2018queryParam\u2019\n   from the context:\n</code></pre> <p>This means that you have used a middleware (or some other function) that is probing for the specified trait (in this case <code>RequiredQueryParam \"tag\" Text</code>) but you have not added a constraint to the type signature of this function.</p> <p>You can fix this by adding the constraint mentioned in the error message to the type signature. You can also combine multiple <code>Get</code> constraints to a single <code>Gets</code> constraint.</p> <p>You might get a similar error for missing <code>Set</code> constraints:</p> <pre><code>Could not deduce (Set h (Body JSON ErrorResponse) Response)\n     arising from a use of \u2018respondA\u2019\n</code></pre> <p>In this case, you can add the specified constraint to the handler.</p>"},{"location":"user-guide/reference/troubleshooting/#missing-trait-proofs","title":"Missing Trait Proofs","text":"<pre><code>Could not deduce (HasTrait (RequiredQueryParam \"offset\" Int) req)\n     arising from a use of \u2018from\u2019\n</code></pre> <p>In this case, you are missing a proof that a witnessed request has certain traits. There are a few possible fixes:</p> <ol> <li>Make sure that the specified trait is actually required by your handler and the type    level literals such as \"offset\" are spelled correctly.</li> <li>Did you add a correct middleware in this handler? For example, this error suggests that it is looking for a    <code>queryParam @\"offset\" @Int</code> middleware. Did you intend to add that middleware before invoking <code>from</code>?</li> <li>Alternatively, you may want to add that middleware in the function calling the current handler. In that case, you can    add the <code>HasTrait (RequiredQueryParam \"offset\" Int) req</code> constraint to the current handler.</li> </ol> <p>If you have many such handlers, use <code>HaveTraits [t1, t2, ....] req</code> instead where <code>t1</code>, <code>t2</code>, ... are traits.</p>"}]}