{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"WebGear - Composable, type-safe APIs in Haskell","text":"<p>Webgear is a framework to build HTTP APIs in Haskell. WebGear helps to run these APIs as a web application, automatically generate OpenAPI documentation, and extract other static information about the APIs in general.</p> <p>WebGear is developer-friendly. While WebGear internally uses many advanced language extensions, considerable effort is spent in exposing only a small portion of it in user APIs so that you need not be an expert to use them. It also has comprehensive documentation and examples that shortens the learning curve.</p> <p>WebGear is very flexible, allowing you to build your project the way you want. It is very easy to extend or completely replace most of the components to make it work the way you need it to.</p> <p>Learn more about WebGear and how it compares against alternatives in the tutorial.</p>"},{"location":"packages/","title":"WebGear Packages","text":"<p>The following packages are available on Hackage and Stackage.</p> <ul> <li> <p>webgear-core:</p> <p>This package defines the core components of WebGear used to define APIs.</p> <ul> <li>Hackage</li> <li>Stackage</li> </ul> </li> <li> <p>webgear-server:</p> <p>This package helps to generate WAI applications based on WebGear API specifications.</p> <ul> <li>Hackage</li> <li>Stackage</li> </ul> </li> <li> <p>webgear-openapi:</p> <p>This package can be used to generate OpenAPI specifications from WebGear applications.</p> <ul> <li>Hackage</li> <li>Stackage</li> </ul> </li> <li> <p>webgear-swagger:</p> <p>This package can be used to generate Swagger 2.0 specifications from WebGear applications.</p> <ul> <li>Hackage</li> <li>Stackage</li> </ul> </li> <li> <p>webgear-swagger-ui:</p> <p>This package provides an endpoint to launch swagger-ui to browse Swagger 2.0 / OpenAPI specifications.</p> <ul> <li>Hackage</li> <li>Stackage</li> </ul> </li> </ul>"},{"location":"tutorial/advanced/arrows-primer/","title":"Arrows Primer","text":"<p>Arrows - like monads - are an abstraction to represent computations with a context. However, they can express contexts that are not possible with monads.</p> <p>WebGear makes extensive use of arrows to build APIs, hence it is important that you have a good grasp of them to effectively use WebGear.</p>"},{"location":"tutorial/advanced/arrows-primer/#basics","title":"Basics","text":"<p>Intuitively, arrows are similar to functions. Like functions, arrows have kind <code>Type -&gt; Type -&gt; Type</code>. That is, they take an input and an output type arguments. Throughout this chapter, we'll use the type variable <code>h</code> to indicate an arrow. Hence, <code>h a b</code> is an arrow with <code>a</code> as the input type and <code>b</code> as the output type.</p> <p>One significant similarity of arrows and functions is that both are composable. Arrows have Category as a superclass. Category is defined as:</p> <pre><code>class Category cat where\n  id :: cat a a                         -- The identity arrow\n  (.) :: cat b c -&gt; cat a b -&gt; cat a c  -- Associative composition\n</code></pre> <p>You are probably already familiar with <code>id</code> and <code>(.)</code> as identity function and function composition. <code>Category</code> is a generalization of these, it represents all types that can be composed like functions.</p> <p>There are two composition operators that make the direction of composition explicit:</p> <pre><code>-- Right to left composition\n(&lt;&lt;&lt;) :: Category cat =&gt; cat b c -&gt; cat a b -&gt; cat a c\n-- Left to right composition\n(&gt;&gt;&gt;) :: Category cat =&gt; cat a b -&gt; cat b c -&gt; cat a c\n</code></pre> <p>The <code>Arrow</code> type class is defined as:</p> <pre><code>class Category h =&gt; Arrow h where\n  -- convert a function to an arrow\n  arr :: (a -&gt; b) -&gt; h a b\n  -- map over the input type\n  first :: h a b -&gt; h (a, c) (b, c)\n  -- map over the output type\n  second :: h a b -&gt; h (c, a) (c, b)\n  --- combine two arrows\n  (***) :: h a b -&gt; h c d -&gt; h (a, c) (b, d)\n  (&amp;&amp;&amp;) :: h a b -&gt; h a c -&gt; h a (b, c)\n</code></pre> <p>These methods allow us to operate on multiple inputs and/or outputs represented as pairs in a single computation.</p> <p>Note that all operations you saw above manipulate and compose arrows in various ways to produce other arrows. But none of them allow you to \"execute\" an arrow - i.e. provide an input to an arrow and get an output. This is not part of the <code>Arrow</code> interface, but a specific arrow type might have such a mechanism.</p> <p>This is similar to the monad interface. The <code>Monad</code> type class defines a <code>return</code> method to lift a value into monadic context and <code>&gt;&gt;=</code> to bind two monadic computations. But there is no method to extract a value from a monadic context. Specific monads (for e.g., <code>Maybe</code>, <code>Either</code>, etc.) might provide some mechanism to extract a value from a monad. But it is not possible with many other monads (for e.g., <code>IO</code>, <code>Const</code>, etc.).</p> <p>In WebGear, you would compose handler arrows to form a single handler. The <code>ServerHandler</code> type allows you to provide a <code>Request</code> as input to this arrow and get a <code>Response</code> as output. This is how <code>webgear-server</code> package implements its API servers. The <code>OpenApiHandler</code> from <code>webgear-openapi</code> package do not have any mechanisms to run a server. Instead, it can extract static information about the APIs to generate OpenAPI documentation.</p>"},{"location":"tutorial/advanced/arrows-primer/#conditionals","title":"Conditionals","text":"<p>The <code>Arrow</code> type class is not expressive enough to build APIs. We often need to conditionally perform actions in a handler. This is where <code>ArrowChoice</code> type class comes in:</p> <pre><code>class Arrow h =&gt; ArrowChoice h where\n  left  :: h a b -&gt; h (Either a c) (Either b c)          -- maps over left option\n  right :: h a b -&gt; h (Either c a) (Either c b)          -- maps over right option\n  (+++) :: h a c -&gt; h b d -&gt; h (Either a b) (Either c d) -- maps over both left and right\n  (|||) :: h a c -&gt; h b c -&gt; h (Either a b) c            -- (+++), then merge results\n</code></pre> <p>These arrows operate on <code>Either</code> values and choose different arrows to handle <code>Left</code> and <code>Right</code> cases.</p> <p>In WebGear, <code>ArrowChoice</code> interface is used to generate different responses based on request traits. For example, if a handle requires a query parameter, we want to generate a 404 response when it is missing. Thus, we need two different handlers - one for the case where we have the query parameter in the request and another one where we don't. The <code>|||</code> operator achieves this by producing an arrow that takes an <code>Either a b</code> value as input and invoking one of the two handlers based on the input.</p>"},{"location":"tutorial/advanced/arrows-primer/#monoid-operations","title":"Monoid Operations","text":"<p>There are cases where we want to combine multiple arrows to form a single arrow. Some arrows support this operation with <code>ArrowZero</code> and <code>ArrowPlus</code> type classes.</p> <pre><code>class Arrow h =&gt; ArrowZero h where\n  zeroArrow :: h a b\n\nclass ArrowZero h =&gt; ArrowPlus h where\n  (&lt;+&gt;) :: h a b -&gt; h a b -&gt; h a b\n</code></pre> <p>Notice the similarity of these classes to <code>Semigroup</code> and <code>Monoid</code> respectively. They define an associative binary operation to combine two arrows and also a <code>zeroArrow</code> that acts as an identity for the <code>&lt;+&gt;</code> operation. In other words, for any arrow <code>h</code>, you have <code>h &lt;+&gt; zeroArrow = h</code> and <code>zeroArrow &lt;+&gt; h = h</code>.</p> <p>In WebGear, these type classes are used to implement routing. The <code>zeroArrow</code> is a handler that always fails, indicating a route mismatch so that other handlers can be tried. In case of <code>f &lt;+&gt; g</code>, the <code>f</code> handler is tried first to get a response. If that fails to match the route, the <code>g</code> handler will be tried next.</p>"},{"location":"tutorial/advanced/arrows-primer/#the-proc-notation","title":"The proc Notation","text":"<p>The arrow combinators are cumbersome to program with in practice. For example, consider this code:</p> <pre><code>squareA :: Arrow h =&gt; h Int Int\nsquareA = arr (\\x -&gt; x * x)\n\npythagorasA :: Arrow h =&gt; h (Int, Int) Int\npythagorasA = (squareA *** squareA) &gt;&gt;&gt; arr (uncurry (+))\n</code></pre> <p>It isn't immediately obvious what <code>pythagorasA</code> is trying to do. It'll help if we had some notation to add extra variable names for intermediate values. That is where <code>proc</code> notation comes in. This syntax is enabled by the <code>Arrows</code> language extension. The above program can be written with proc notation as:</p> <pre><code>squareA :: Arrow h =&gt; h Int Int\nsquareA = proc x -&gt;\n  returnA -&lt; x * x\n\npythagorasA :: Arrow h =&gt; h (Int, Int) Int\npythagorasA = proc (x, y) -&gt; do\n  xSquare &lt;- squareA -&lt; x\n  ySquare &lt;- squareA -&lt; y\n  returnA -&lt; xSquare + ySquare\n</code></pre> <p>The proc notation is similar to the monadic do notation. The main difference is that an arrow has both an input and output components, unlike monad which only has one.</p> <p>The proc block starts with the <code>proc</code> keyword followed by a pattern representing the input to this arrow. For example, the <code>pythagorasA</code> arrow has <code>(x, y)</code> as its input.</p> <p>The body of the arrow notation is called a command. There are a few possible ways to write a command. In the above code, <code>squareA</code> has a single command <code>returnA -&lt; x * x</code> as its body. This means <code>x * x</code> is sent as input to <code>returnA</code> and its output is the output of <code>squareA</code>. <code>returnA</code> is the identity arrow, so effectively <code>squareA</code> returns the square of its input.</p> <p>In general, this has the form <code>aexp -&lt; iexp</code> where <code>aexp</code> is an expression evaluating to an arrow and <code>iexp</code> is an expression evaluating to its input.</p> <p>More complex arrows - such as <code>pythagorasA</code> - use a do block. In the first line <code>xSquare &lt;- squareA -&lt; x</code>, the value <code>x</code> is input to the arrow <code>squareA</code> and the result is <code>xSquare</code>. The final line feeds <code>xSquare + ySquare</code> to <code>returnA</code> which produces the result of <code>pythagorasA</code>.</p> <p>There are a few restrictions on what you can do with this notation. Firstly, the part to the left of <code>&lt;-</code> is a pattern just like the monadic do notation.</p> <p>Secondly, the expression between <code>&lt;-</code> and <code>-&lt;</code> must be an arrow. This expression cannot use any of the variables bound in the proc notation. For example, the code below is invalid because the <code>x</code> is bound as a result in first line and is used as part of the arrow expression in second line.</p> <pre><code>proc a -&gt; do\n  x &lt;- foo -&lt; a\n  y &lt;- bar x -&lt; a\n  ....\n</code></pre> <p>Arrows do not let you choose the next arrow to use based on some intermediate result from a previous arrow.(1) Bound variables such as <code>x</code> and <code>y</code> can only be used as an input to other arrows (i.e. on the right side of <code>-&lt;</code>).  { .annotate }</p> <ol> <li><code>ArrowApply</code> type class allows this. But such arrows are equivalent to monads and you are better off using     monads in that case.</li> </ol> <p>The proc notation also supports <code>if</code> and <code>case</code> in commands. These require an instance of <code>ArrowChoice</code>:</p> <pre><code>factorialA :: ArrowChoice h =&gt; h Int Int\nfactorialA = proc n -&gt;\n  if n == 0\n    then returnA -&lt; 1\n    else do\n      res &lt;- factorialA -&lt; n - 1\n      returnA -&lt; n * res\n\ndata Result = Found [Pet] | NotFound\n\nsearchPets :: ArrowChoice h =&gt; h Name Result\nsearchPets = proc name -&gt; do\n  pets &lt;- fetchPetsFromDB -&lt; name\n  case pets of\n    [] -&gt; returnA -&lt; NotFound\n    ps -&gt; returnA -&lt; Found ps\n</code></pre>"},{"location":"tutorial/advanced/arrows-primer/#summary","title":"Summary","text":"<p>Arrows can be used to build composable programs. You can compose many arrows in multiple ways to produce a resultant arrow, and then in the next step run that arrow. The clean separation between these two steps help WebGear to retain static information about APIs as well as run it as a server.</p> <p>See these resources for more information about arrows:</p> <ol> <li>The Haskell wikibook has a chapter on arrows.</li> <li>Haskell wiki has an arrow tutorial.</li> <li>These two papers introduce arrows from first principles and are easy to read:</li> <li>Generalising Monads to Arrows</li> <li>Programming with Arrows</li> </ol>"},{"location":"tutorial/advanced/traits/","title":"Trait Internals","text":"<p>The previous section of the tutorial showcased many traits and middlewares included in WebGear. Occasionally, you may want to extend these traits or implement your own traits. This chapter reveals all the internals of traits to help you do this.</p>"},{"location":"tutorial/advanced/traits/#basics","title":"Basics","text":"<p>The traits included in <code>webgear-core</code> package are not special in anyway; you may define your own traits that are as first-class as the traits provided by WebGear. We'll use an example to demonstrate this.</p> <p>Many systems use a special HTTP header <code>X-Request-ID</code> for distributed tracing. This header value is often included in logs and telemetry to trace the progress of a request through all the systems involved in processing it. </p>"},{"location":"tutorial/advanced/traits/#implementation","title":"Implementation","text":"<p>Let us see how to implement a trait to capture the request ID value from HTTP requests.</p>"},{"location":"tutorial/advanced/traits/#1-define-a-trait-type","title":"1. Define a Trait Type","text":"<p>The first step in defining any trait is to define a type representing the trait. Here is the type for our request ID trait:</p> <pre><code>data RequestID = RequestID\n</code></pre> <p>We don't need anything fancy here because our trait is very simple. If you need any additional configuration associated with your trait, you may let the data constructor accept those as parameters.</p>"},{"location":"tutorial/advanced/traits/#2-define-a-trait-attribute","title":"2. Define a Trait Attribute","text":"<p>Next we define a type for the attribute value associated with our trait type. This is the value that we get when we extract the request ID successfully from the request.</p> <pre><code>newtype RequestIDValue = RequestIDValue Text\n\ntype instance Attribute RequestID Request = RequestIDValue\n</code></pre> <p>We use a newtype wrapper around <code>Text</code> as we don't assume any further structure to the request ID header.</p>"},{"location":"tutorial/advanced/traits/#3-define-trait-absence","title":"3. Define Trait Absence","text":"<p>Next we need to handle the case of missing trait attributes. What if the request does not contain a request ID? We'll indicate that as an error.</p> <pre><code>data RequestIDMissing = RequestIDMissing\n\ntype instance Absence RequestID = RequestIDMissing\n</code></pre>"},{"location":"tutorial/advanced/traits/#4-define-prerequisites","title":"4. Define Prerequisites","text":"<p>Optionally, a trait can have prerequisites. These are usually other traits that you want to depend on. In this case, we'll use <code>OptionalRequestHeader</code> as a prerequisite because the request ID is derived from a request header.</p> <pre><code>type RequestIDHeader = RequestHeader Optional Lenient \"X-Request-ID\" Text\n\ntype instance Prerequisite RequestID ts = HasTrait RequestIDHeader ts\n</code></pre> <p>You may set this type instance to <code>()</code> if the trait does not have any prerequisites.</p>"},{"location":"tutorial/advanced/traits/#5-implement-get-instances","title":"5. Implement Get Instances","text":"<p>Now we can implement instances of <code>Get</code> type class for each type of handler arrows that we want to support.</p> <pre><code>instance Monad m =&gt; Get (ServerHandler m) RequestID where\n  getTrait ::\n    HasTrait RequestIDHeader ts =&gt;\n    RequestID -&gt;\n    ServerHandler m (Request `With` ts) (Either RequestIDMissing RequestIDValue)\n  getTrait RequestID = proc request -&gt; do\n    let hdr = pick @RequestIDHeader $ from request\n    case hdr of\n      Just (Right val) -&gt; returnA -&lt; Right (RequestIDValue val)\n      Just (Left _) -&gt; returnA -&lt; Left RequestIDMissing\n      Nothing -&gt; returnA -&lt; Left RequestIDMissing\n</code></pre> <p>Notice how the implementation uses the prerequisite to get the header value. The <code>getTrait</code> method returns an <code>Either</code> value - the <code>Left</code> value must be of the <code>Absence</code> type and the <code>Right</code> value must be of the <code>Attribute</code> type.</p> <p>You can also define additional <code>Get</code> type class instances - for example, define an <code>OpenApiHandler</code> instance if you want to include this trait in the OpenAPI documentation.</p>"},{"location":"tutorial/advanced/traits/#6-implement-a-middleware","title":"6. Implement a Middleware","text":"<p>It is a good practice to define one or more middlewares for your trait. They make it convenient to use the trait in API handlers. Here is a middleware for the request ID trait.</p> <pre><code>requestID ::\n  (Get h RequestID, ArrowChoice h, HasTrait RequestIDHeader ts) =&gt;\n  h (Request `With` ts, RequestIDMissing) Response -&gt;\n  Middleware h ts (RequestID : ts)\nrequestID errorHandler nextHandler =\n  proc request -&gt; do\n    result &lt;- probe RequestID -&lt; request\n    case result of\n      Left e -&gt; errorHandler -&lt; (request, e)\n      Right request' -&gt; nextHandler -&lt; request'\n</code></pre> <p>The <code>probe</code> arrow makes use of the <code>getTrait</code> implementation above. If <code>getTrait</code> fails with an error, probe too will fail with a <code>Left</code> value. But if <code>getTrait</code> succeeds, <code>probe</code> will return a request value with the additional <code>RequestID</code> trait attached to it. In other words, the type of <code>request'</code> in the above middleware is <code>Request `With` (RequestID : ts)</code>.</p> <p>As with other handlers we've seen so far, this middleware is also polymorphic in the type variable <code>h</code>. It will use the appropriate handler arrow as required - <code>ServerHandler</code>, <code>OpenApiHandler</code>, etc.</p>"},{"location":"tutorial/first-steps/getting-started/","title":"Getting Started","text":"<p>WebGear is a collection of Haskell packages and can be added to your Haskell project just like any other package.</p> <p>This version of WebGear supports GHC versions from <code>9.0</code> till <code>9.8</code>. WebGear supports both Cabal and Stack. The rest of this guide contains instructions only for Cabal, but they can be adjusted easily for Stack.</p>"},{"location":"tutorial/first-steps/getting-started/#first-project","title":"First Project","text":"<p>Let's create the customary hello world project using WebGear. First, create a new Haskell project with Cabal:</p> <pre><code>$ mkdir webgear-tutorial\n$ cd webgear-tutorial\n$ cabal init --minimal --non-interactive --exe\n</code></pre> <p>We'll need a number of language extensions and package dependencies in the cabal file. Edit <code>webgear-tutorial.cabal</code> and add them:</p> <pre><code>default-extensions:\n    Arrows\n    DataKinds\n    DerivingStrategies\n    FlexibleContexts\n    GeneralizedNewtypeDeriving\n    OverloadedStrings\n    QuasiQuotes\n    ScopedTypeVariables\n    TypeApplications\n    TypeOperators\n\nbuild-depends:\n    base,\n    http-api-data ==0.6,\n    http-types ==0.12.4,\n    openapi3 ==3.2.4,\n    time,\n    wai ==3.2.4,\n    warp ==3.4.1,\n    webgear-core ==1.3.0,\n    webgear-server ==1.3.0,\n    webgear-openapi ==1.3.0\n</code></pre> <p>Edit <code>app/Main.hs</code> and replace its contents with:</p> <pre><code>module Main where\n\nimport WebGear.Core\nimport WebGear.Server\nimport qualified Network.HTTP.Types as HTTP\nimport qualified Network.Wai as Wai\nimport qualified Network.Wai.Handler.Warp as Warp\n\nmain :: IO ()\nmain = Warp.run 3000 helloApp\n\nhelloApp :: Wai.Application\nhelloApp = toApplication $\n  [route| HTTP.GET /hello |] $\n    proc request -&gt;\n      respondA HTTP.ok200 PlainText -&lt; \"Hello, World!\" :: Text\n</code></pre> <p>In the above code, WebGear checks if the request method is <code>GET</code> and the request URL is <code>/hello</code>. If both these conditions are met, a request handler is invoked. The handler is implemented as an arrow - hence the use of <code>proc</code> syntax. It ignores the <code>request</code> input and responds with a 200 OK response having a <code>text/plain</code> content type and a <code>Hello, World</code> body.</p> <p>Tip</p> <p>If you are unfamiliar with Haskell arrows, you are strongly recommended to go through the Arrows Primer chapter.</p>"},{"location":"tutorial/first-steps/getting-started/#trying-it-out","title":"Trying It Out","text":"<p>You may launch the API server with:</p> <pre><code>$ cabal run\n</code></pre> <p>And test it with:</p> <pre><code>$ curl --dump-header - http://localhost:3000/hello\nHTTP/1.1 200 OK\nTransfer-Encoding: chunked\nDate: Wed, 15 May 2024 19:15:46 GMT\nServer: Warp/3.4.1\nContent-Type: text/plain\n\nHello, World!\n</code></pre>"},{"location":"tutorial/first-steps/getting-started/#summary","title":"Summary","text":"<p>Congratulations! You've got a basic WebGear application server working. In the next chapter, you'll learn more about routing HTTP requests and handlers.</p>"},{"location":"tutorial/first-steps/introduction/","title":"Introduction","text":""},{"location":"tutorial/first-steps/introduction/#what-is-webgear","title":"What is WebGear?","text":"<p>WebGear is a high-performance framework to build composable, type-safe HTTP APIs. It is designed to make common API development tasks easy. WebGear is easily customizable to match the requirements of your project.</p>"},{"location":"tutorial/first-steps/introduction/#why-use-webgear","title":"Why use WebGear?","text":"<p>If you are already familiar with other Haskell web frameworks, you might be interested in how WebGear compares against them. This section compares WebGear against some popular frameworks to give you an idea of why it is useful.</p>"},{"location":"tutorial/first-steps/introduction/#servant","title":"Servant","text":"<p>Servant uses advanced type level combinators to express API components, while WebGear has traits which are regular data types combined with a few type class instances. Most of the differences between WebGear and Servant stem from this. Note that WebGear do use type-level lists of traits for building type-safe APIs. But that is a fairly limited usage of type-level programming and is easier to learn.</p> <ul> <li>Programming at type level is more verbose and require knowledge of advanced extensions. This is avoided in WebGear by   doing most of the operations at value level instead of type level.</li> <li>Some type-level structures are not as composable as regular values. For example, a package like   servant-flatten is needed to factor out combinators. WebGear does not   have this problem, simply because it uses function calls and function composition to express APIs.</li> <li>It is hard to express certain ideas at type-level. For example, basic authentication support in Servant requires a   <code>Context</code> that specifies a function to validate credentials. It is required to use this ad-hoc approach because   Servant combinators are at type level and cannot include a function. On the other hand, WebGear traits can include   functions in them because they are values.</li> <li>Servant is a very popular project with a large ecosystem of companion packages. WebGear is a younger project, and may   not support such a wide variety of functionality.</li> </ul>"},{"location":"tutorial/first-steps/introduction/#ihp","title":"IHP","text":"<p>IHP is an opinionated full-stack framework for rapid application development. You can build everything from the DB schema to UI with IHP. It can significantly reduce the development time by using standardized steps to build various components. However, it may not be suitable for your specific use case and constraints. For example, IHP requires the use of Nix, and PostgreSQL is the only supported database. Your applications may not always be compatible with such constraints.</p> <p>WebGear does not aim to be a full-stack framework. It focuses on doing one thing well - building APIs. You are free to choose a UI framework, a persistence backend, build tool as your project demands.</p>"},{"location":"tutorial/first-steps/introduction/#scotty","title":"Scotty","text":"<p>Scotty is a minimalist framework to build web applications. It is trivial to build simple web applications in Scotty, but it does not support many of the WebGear features such as type-safety provided by traits, ability to build reusable components, automatic generation of OpenAPI documentation etc.</p>"},{"location":"tutorial/first-steps/introduction/#other-differences","title":"Other Differences","text":"<p>WebGear uses arrows and monads to build APIs, while other frameworks only use monads. This requires you to understand one additional concept of arrows; however, this cost is justified as arrows can express API specifications at value level instead of type level. Arrows and their <code>proc</code> notation can be learned relatively easily as a natural extension of monadic computation. If you are unfamiliar with arrows, you may want to go through the arrows primer.</p>"},{"location":"tutorial/request-handling/api-documentation/","title":"API Documentation","text":"<p>You can generate OpenAPI 3 specifications from your handlers using the <code>webgear-openapi</code> package. This chapter describes how to do that.</p> <p>Note</p> <p>There is also the <code>webgear-swagger</code> package that generates Swagger 2.0 specification. Most of the instructions in this chapter can be tweaked to work with that package as well.</p>"},{"location":"tutorial/request-handling/api-documentation/#openapihandler","title":"OpenApiHandler","text":"<p>In the Handlers and Middlewares chapter, we encountered the type <code>RequestHandler h ts</code>. We learned that <code>#hs h</code> is the underlying arrow of the handler. So far, we used the type <code>ServerHandler m</code> in  place of <code>h</code>. And now, we are going to use a different arrow - <code>OpenApiHandler m</code> - that can generate OpenAPI  specifications.</p> <p>As we were using the polymorphic type for our handlers, we don't need to change them at all. Here is the definition of  <code>currentTimeHandler</code> we encountered earlier.</p> <pre><code>import Control.Monad.IO.Class\nimport Data.Time\nimport qualified Network.Wai.Handler.Warp as Warp\nimport WebGear.Server (toApplication)\n\ncurrentTimeHandler ::\n  forall h m ts.\n  (StdHandler h m, MonadIO m) =&gt;\n  RequestHandler h ts\ncurrentTimeHandler =\n  [route| HTTP.GET /api/now |] $\n    proc request -&gt; do\n      now &lt;- arrM getNow -&lt; ()\n      respondA HTTP.ok200 PlainText -&lt; show now\n      where\n        getNow :: () -&gt; m UTCTime\n        getNow () = liftIO getCurrentTime\n\nmain :: IO ()\nmain = Warp.run 3000 $ toApplication currentTimeHandler\n</code></pre> <p>You can generate OpenAPI specification of this API with:</p> <pre><code>import Data.OpenApi (OpenApi)\nimport WebGear.OpenApi (toOpenApi)\n\nspecs :: OpenApi\nspecs = toOpenApi @IO currentTimeHandler\n</code></pre> <p>That's it! The same handler can generate both a Wai application and its OpenAPI documentation. All the effort we spent in expressing APIs using traits and middlewares makes this possible.</p>"},{"location":"tutorial/request-handling/generating-responses/","title":"Generating Responses","text":"<p>All handlers must respond with a valid HTTP response. This chapter discusses different ways to create and return a response from handlers.</p>"},{"location":"tutorial/request-handling/generating-responses/#basic-responses","title":"Basic Responses","text":"<p>The easiest way to return a response is to use the <code>respondA</code> arrow. You've already seen it in use a few times:</p> <pre><code>import qualified Network.HTTP.Types as HTTP\n...\nrespondA HTTP.ok200 PlainText -&lt; \"Hello, WebGear\"\n</code></pre> <p>The first argument to <code>respondA</code> is the HTTP status code and the second argument is the MIME type of the response.  The body is passed as the input to the arrow. Needless to say, the type of the body must be compatible with the MIME type. For e.g., the <code>JSON</code> MIME type requires that the type of the body has an instance of the <code>ToJSON</code> type class from the aeson package.</p> <p>In general, the MIME type and the body type are connected via the <code>WebGear.Server.MIMETypes.BodyRender</code> type class. An instance of this type class must exist to use that body type with the MIME type.</p>"},{"location":"tutorial/request-handling/generating-responses/#advanced-responses","title":"Advanced Responses","text":"<p>While <code>respondA</code> is useful, there are cases where you might need lower level access to the response generation. Fortunately, that's very easy with WebGear.</p> <p>You can generate an empty response with just a status code using <code>WebGear.Core.Trait.Status.mkResponse</code>. It works like this:</p> <pre><code>proc x -&gt; do\n  response &lt;- mkResponse HTTP.ok200 -&lt; ()\n  unwitnessA -&lt; response\n</code></pre> <p>The <code>unwitnessA</code> arrow converts a value of type <code>Response `With` ts</code> to a value of type <code>Response</code>. In other words, it removes all the trait evidences associated with the response. This must be done before the handler returns the response to the caller.</p> <p>The <code>WebGear.Core.Trait.Status</code> module contains convenience functions to generate responses for all common status codes.</p> <p>You can specify the response body either using <code>WebGear.Core.Trait.Body.setBody</code> or  <code>WebGear.Core.Trait.Body.setBodyWithoutContentType</code>. As the name indicates, the latter does not require you to know the MIME type in advance.</p> <pre><code>proc x -&gt; do\n  response &lt;- mkResponse HTTP.ok200 -&lt; ()\n  let body = MyJSONRecord{...}\n  response' &lt;- setBody JSON -&lt; (response, body)\n  unwitnessA -&lt; response\n</code></pre> <p>You can specify response headers using <code>WebGear.Core.Trait.Header.setHeader</code> arrow:</p> <pre><code>proc x -&gt; do\n  response &lt;- mkResponse HTTP.ok200 -&lt; ()\n  response' &lt;- setHeader @\"Cache-Control\" @Text -&lt; (response, \"max-age=180\")\n  unwitnessA -&lt; response\n</code></pre> <p>All these arrows assume that you know the response traits statically. In the above examples, you knew the HTTP status code, the body MIME type, and the header name without having to invoke the handler with a request. On the other hand, the response body value and the header value were passed as inputs to these arrows; i.e they are dynamically computed when the handler is executed.</p> <p>This separation of static an dynamic parts of an API allows WebGear to extract the static information without having to execute the handler. By examining the handler, WebGear deduces that it returns an HTTP response with status code 200, having a JSON body, and a <code>Cache-Control</code> header. This is useful in many ways; for e.g. this allows us to generate documentation or generate clients automatically.</p> <p>What if you truly do not know static information about some traits? What if you need to dynamically compute them? You can definitely do that. The <code>WebGear.Core.Response</code> module shows how you can construct a response without using any of the trait machinery. The <code>Response</code> type has data constructors that are very similar to the <code>Response</code> type from Wai. </p> <p>For example:</p> <pre><code>proc x -&gt; do\n  status &lt;- arrM getResponseStatus -&lt; ()\n  headers &lt;- arrM getResponseHeaders -&lt; ()\n  body &lt;- arrM getResponseBody -&lt; ()\n  returnA -&lt; Response status headers body\n</code></pre> <p>This response is entirely computed at runtime and you don't use the trait mechanism at all. However, there is a trade-off: WebGear does not know any static information about it. As a consequence, you lose the ability to generate documentation from this handler.</p> <p>You may also choose to dynamically generate some parts of the response while using traits for the rest. This will retain some static information about the handlers that might come handy.</p>"},{"location":"tutorial/request-handling/generating-responses/#mime-types","title":"MIME Types","text":"<p>MIME types are used to convert a request body to a Haskell value or to generate a response body from a Hakell value. Commonly used MIME types are defined in <code>WebGear.Core.MIMETypes</code> module; but you may define your own MIME types if required.</p> <p>The first step to add a new MIME type is to define a Haskell type for it and provide an instance of the <code>WebGear.Core.MIMETypes.MIMEType</code> type class. This type class has a single method - <code>mimeType</code> - to determine the media type associated with the MIME type.</p> <p>Next, define a couple more type class instances from the <code>WebGear.Server.MIMETypes</code> module.</p> <p>The <code>BodyRender</code> type class is used to serialize a Haskell value to a response body. The <code>BodyUnrender</code> type class works parses the request body into a Haskell value. Defining instances for these two classes allows you to use your MIME type in request/response handling.</p>"},{"location":"tutorial/request-handling/generating-responses/#summary","title":"Summary","text":"<p>Response generation is very straightforward in WebGear. At the same time, you have the flexibility to bypass WebGear's trait machinery should the need arise.</p>"},{"location":"tutorial/request-handling/handlers-and-middlewares/","title":"Handlers and Middlewares","text":"<p>Now that you've learned how routing works, it is time to learn about request handlers.</p> <p>A typical web application will extract some data from the request, do some processing, and then produce a response. WebGear request handlers help to implement all these three steps in a convenient, type-safe manner. Let us see how.</p>"},{"location":"tutorial/request-handling/handlers-and-middlewares/#request-handlers","title":"Request Handlers","text":"<p>A request handler is an arrow that takes a request as input and produces a response as output. You already saw a few handlers in this tutorial. They have a few properties that you should learn to use WebGear effectively.</p> <p>Request handlers represent an abstract computation that can derive a response based on a request. This abstract computation can be converted to a concrete web application by passing it to the <code>toApplication</code> function. You already saw the usage of <code>toApplication</code> in previous chapters, but we never mentioned that its argument is a handler.</p> <p>Request handlers are composable. In the routing chapter, you saw that multiple endpoints can be combined with the <code>&lt;+&gt;</code> operator to produce a single handler.</p>"},{"location":"tutorial/request-handling/handlers-and-middlewares/#middlewares","title":"Middlewares","text":"<p>A middleware is a function that takes a handler as input and produces another handler as output. You've encountered a few middlewares already even though they weren't explicitly labelled so. The <code>method</code>, <code>path</code>, <code>pathVar</code>, and <code>pathEnd</code> functions from the routing are examples of middlewares. They accept a handler as input and invokes it only if some criteria is met.</p> <p>Since middlewares return a handler, we can chain them together and produce a handler as shown in the example below:</p> <pre><code>method HTTP.GET $ path \"/api/user\" $ pathVar @\"userId\" @Int $ pathEnd userHandler\n</code></pre>"},{"location":"tutorial/request-handling/handlers-and-middlewares/#traits","title":"Traits","text":"<p>WebGear has many more middlewares, we'll explore them in the next chapter. For now, let us turn our attention to the <code>pathVar</code> middleware. In the code above, <code>pathVar @\"userId\" @Int</code> extracts a path variable of type <code>Int</code>. How can we use this variable in our handler?</p> <pre><code>method HTTP.GET $ path \"/api/user\" $ pathVar @\"userId\" @Int $ pathEnd $\n  proc request -&gt; do\n    let userId :: Int\n        userId = pick @(PathVar \"userId\" Int) $ from request\n    respondA HTTP.ok200 PlainText -&lt; \"ID = \" &lt;&gt; show userId\n</code></pre> <p>You just pick the value from the request. But how do we know that the request contains such a path variable? After all, the request can contain a completely different path. Note that the type of <code>userId</code> is <code>Int</code>. Shouldn't it be <code>Maybe Int</code> to accommodate the case where the request does not have the path variable?</p> <p>Let us experiment a little bit; what if you remove the <code>pathVar</code> middleware from the code?</p> <pre><code>method HTTP.GET $ path \"/api/user\" $ pathEnd $\n  proc request -&gt; do\n    let userId :: Int\n        userId = pick @(PathVar \"userId\" Int) $ from request\n    respondA HTTP.ok200 PlainText -&lt; \"ID = \" &lt;&gt; show userId\n</code></pre> <p>Try compiling this code and you'll get an error:</p> <pre><code>\u2022 The value doesn't have the \u2018PathVar \"userId\" Int\u2019 trait.\n\n  Did you forget to apply an appropriate middleware?\n  ...\n\n  or did you use a wrong trait type?\n  ...\n</code></pre> <p>That's very impressive. WebGear stops us from using an attribute that could be missing from the request. We can't pick the path variable from the request unless we have used the appropriate middleware. How does that work? What is this trait mentioned in the error message?</p> <p>It'll be clearer if we add a type signature to the handler:</p> <pre><code>myApp :: Wai.Application\nmyApp = toApplication $\n  method HTTP.GET $ path \"/api/user\" $ pathVar @\"userId\" @Int $ pathEnd userHandler\n\nuserHandler :: HasTrait (PathVar \"userId\" Int) ts =&gt; ServerHandler IO (Request `With` ts) Response\nuserHandler = proc request -&gt; do\n  let userId :: Int\n      userId = pick @(PathVar \"userId\" Int) $ from request\n  respondA HTTP.ok200 PlainText -&lt; \"ID = \" &lt;&gt; show userId\n</code></pre> <p>The type of <code>userHandler</code> is <code>ServerHandler IO (Request</code>With<code>ts) Response</code>. Here, <code>ServerHandler IO</code> is the type of the arrow used as the handler. The arrow input is <code>Request `With` ts</code> and the output is <code>Response</code>.</p> <p>In this type, <code>ts</code> is a list of trait types. You might be wondering, what is a trait? Simply put, traits are attributes associated with a request. <code>PathVar \"userId\" Int</code> is one such trait that represents a path variable. The <code>ts</code> type variable contains all traits that are known to be present in the request. The <code>HasTrait (PathVar\"userId\" Int) ts</code> constraint is an assertion that the path variable trait definitely exists in the list <code>ts</code>. That is why we can use <code>pick @(PathVar \"userId\" Int)</code> to get a user ID without having to handle the case of a missing path variable.</p> <p>In order to satisfy the <code>HasTrait</code> constraint, we must use the <code>pathVar</code> middleware. If you omit that middleware, the constraint will not be satisfied and GHC will show an error message as shown above.</p> <p>In the rest of this tutorial, you will see this pattern used again and again. Your handler will be wrapped in an appropriate middleware and then the handler can access trait using the <code>pick</code> function.</p>"},{"location":"tutorial/request-handling/handlers-and-middlewares/#a-better-type-signature","title":"A Better Type Signature","text":"<p>The type signature of <code>userHandler</code> given above works fine. However, WebGear handlers tend to use a more general type:</p> <pre><code>userHandler :: (StdHandler h m, HasTrait (PathVar \"userId\" Int) ts) =&gt; RequestHandler h ts\n</code></pre> <p><code>RequestHandler h ts</code> is a type synonym and is equivalent to <code>h (Request `With` ts) Response</code>. Doesn't that look very similar to <code>ServerHandler IO (Request `With` ts) Response</code>? Of course, it does. The main change we did is to replace <code>ServerHandler IO</code> with a type variable <code>h</code>.</p> <p>As mentioned above, <code>ServerHandler IO</code> is the type of the arrow used by <code>userHandler</code>. This arrow allows us to convert the handler to a Wai application using the <code>toApplication</code> function. But WebGear handlers are not limited to just being an application. In a later chapter, you'll learn how to generate OpenAPI or Swagger documentation from these handlers. In order to support all such use cases, we switch to a polymorphic type variable <code>h</code> instead of the concrete arrow type <code>ServerHandler IO</code>. WebGear can substitute an appropriate type in place of <code>h</code> depending on the use case.</p> <p>As a result of this change, we need an additional constraint <code>StdHandler h m</code> in the type signature. This constraint enforces that <code>h</code> is a handler arrow and has capabilities that all WebGear handlers are required to have. For example, handler arrows can embed monadic actions in them. We'll see more on that in the next section.</p> <p>Going forward, we will use this polymorphic type signature for all our handlers.</p>"},{"location":"tutorial/request-handling/handlers-and-middlewares/#monadic-actions-in-handlers","title":"Monadic Actions in Handlers","text":"<p>Most WebGear handlers will need some monadic actions to process the request. As an example, let us consider a handler that returns the current date and time in UTC. We can use the <code>Data.Time.getCurrentTime</code> function for this pupose. But, that function has the type <code>IO UTCTime</code>. How do we add it to a handler which is an arrow and not a monad?</p> <p>It is fairly straightforward. All handlers allow embedding monadic actions in them using a function <code>arrM</code>. This is how you'd use it:</p> <pre><code>import Data.Time\nimport Control.Monad.IO.Class\n\ncurrentTimeHandler ::\n  forall h m ts.\n  (StdHandler h m, MonadIO m) =&gt;\n  RequestHandler h ts\ncurrentTimeHandler = proc request -&gt; do\n  now &lt;- arrM getNow -&lt; ()\n  respondA HTTP.ok200 PlainText -&lt; show now\n  where\n    getNow :: () -&gt; m UTCTime\n    getNow () = liftIO getCurrentTime\n</code></pre> <p>If you have a function of type <code>a -&gt; m b</code> where <code>m</code> is a monad, the function <code>arrM</code> can lift it to a handler arrow of type <code>StdHandler h m =&gt; h a b</code>. In the above example, we lifted the <code>getNow</code> function to an arrow of type <code>h () UTCTime</code> and used it inside the <code>proc</code> body.</p> <p>Unlike monads, handlers (and arrows in general) require both an input and an output. The <code>getCurrentTime</code> IO action does not require any inputs and we should convert it to a function by passing <code>()</code> as an input.</p>"},{"location":"tutorial/request-handling/handlers-and-middlewares/#bring-your-own-monad","title":"Bring Your Own Monad","text":"<p>Notice how we used the <code>MonadIO m</code> constraint instead of using the concrete <code>IO</code> type. Using a polymorphic type helps us to switch to a different monad if required without modifying the handler.</p> <p>You may use any monad of your choice with request handlers. However, the <code>toApplication</code> function requires the handler to be based on the <code>#hs IO</code> monad. So, how do you convert handlers based on your custom monad stack to a Wai application?</p> <p>The answer is to use the <code>transform</code> function to convert your monad stack. Let us assume you have a ReaderT stack. This is how you generate a Wai application in that case:</p> <pre><code>apiHandler :: StdHandler h (ReaderT Env IO) =&gt; RequestHandler h ts\napiHandler = ...\n\napplication :: Env -&gt; Wai.Application\napplication env = toApplication $ transform appToIO apiHandler\n  where\n    appToIO :: ReaderT Env a -&gt; IO a\n    appToIO f = runReaderT f env\n</code></pre> <p>The <code>transform</code> function has the following type:</p> <pre><code>transform :: (forall x. m x -&gt; n x) -&gt; ServerHandler m a b -&gt; ServerHandler n a b\n</code></pre> <p>Given a function - such as <code>appToIO</code> above - that transforms one monadic action to another, it can transform between the corresponding <code>ServerHandler</code> types. You then pass the transformed handler to <code>toApplication</code>.</p>"},{"location":"tutorial/request-handling/handlers-and-middlewares/#summary","title":"Summary","text":"<p>In this chapter, you learned the basics of request handlers, middlewares, and traits. By now, you have a good understanding of how traits help in accessing request attributes in a type safe manner. You also learned to write polymorphic type signatures for request handlers.</p> <p>In the next chapter we'll meet many more commonly used middlewares and traits.</p>"},{"location":"tutorial/request-handling/request-traits/","title":"Request Traits","text":"<p>In the last chapter, you learned how to extract a path variable from a request using a middleware. WebGear includes many more traits and middlewares for extracting information from requests. Most of these traits follow a similar pattern. Their usage looks like this:</p> <pre><code>middleware errorHandler $\n  proc request -&gt; do\n    let attribute :: TheAttribute = pick @TheTrait $ from request\n    ...\n</code></pre> <p>As you can see, the trait supports a middleware that you wrap your handler with. Some traits support more than one middleware and you need to select a suitable one.</p> <p>Most of the middlewares accept an error handler as the first argument. This handler deals with situations when the middleware encounters an error and needs to return some kind of an error response.</p> <p>After you wrap the handler with a middleware, you may use the <code>pick</code> function to extract the trait attribute associated with the request. Note that there are two types involved here. <code>TheTrait</code> is the type of the trait and <code>TheAttribute</code> is the type of the associated attribute value. In the path variable example from the previous chapter, these types would be <code>PathVar \"userId\" Int</code> and <code>Int</code> respectively.</p> <p>In summary, if you know the suitable middleware, the trait type, and the attribute type, you can extract that attribute from a request in a type-safe and straightforward manner.</p> <p>Now that you've seen the general pattern of using request traits, what follows is an in-depth look at the traits and middlewares included in WebGear.</p>"},{"location":"tutorial/request-handling/request-traits/#query-parameters","title":"Query Parameters","text":"<p>You can extract query parameters from the request and parse the string value into a Haskell type of your choice. </p> <p>To illustrate this, consider a variation of the <code>currentTimeHandler</code> from the previous chapter. This time our handler will accept a query parameter named <code>diff</code> which must be an integer representing a length of time in seconds. It will then respond with a timestamp calculated by adding this length of time to the current UTC time.</p> <p>Here is how you could implement this:</p> <pre><code>timeHandler ::\n  forall h m ts.\n  (StdHandler h m, MonadIO m, Get h (RequiredQueryParam \"diff\" Integer)) =&gt;\n  RequestHandler h ts\ntimeHandler =\n  queryParam @\"diff\" @Integer errorHandler $\n    proc request -&gt; do\n      let seconds :: Integer = pick @(RequiredQueryParam \"diff\" Integer) $ from request\n      time &lt;- arrM getTimeDiff -&lt; fromInteger seconds\n      respondA HTTP.ok200 PlainText -&lt; show time\n\nerrorHandler :: StdHandler h m =&gt; h (Request `With` ts, Either ParamNotFound ParamParseError) Response\nerrorHandler = proc (_, e) -&gt;\n  case e of\n    Left ParamNotFound -&gt;\n      respondA HTTP.badRequest400 PlainText -&lt; \"Missing query parameter: diff\"\n    Right (ParamParseError msg) -&gt;\n      respondA HTTP.badRequest400 PlainText -&lt; \"Invalid query parameter: diff: \" &lt;&gt; msg\n\ngetTimeDiff :: MonadIO m =&gt; NominalDiffTime -&gt; m UTCTime\ngetTimeDiff diff = addUTCTime diff &lt;$&gt; liftIO getCurrentTime\n</code></pre> <p>Let us examine the important parts of this code.</p> <p>The new constraint <code>Get h (RequiredQueryParam \"diff\" Integer)</code> is added to indicate that the handler arrow <code>h</code> must be capable of retrieving the query parameter trait from the request. Then, we can use the <code>queryParam @\"diff\"@Integer</code> middleware to ensure that the request contains the parameter. After that, we use <code>pick@(RequiredQueryParam \"diff\" Integer)</code> to extract the parameter value as an integer.</p> <p>Finally, pay close attention to the type of <code>errorHandler</code>. It's input is a pair containing the original request and an error object. There are two possible types of error - either the parameter is missing or it cannot be parsed as an integer. These two cases are represented using the type <code>Either ParamNotFound ParamParseError</code>.</p> <p>WebGear has three more middlewares related to query parameters. They are listed below:</p> Middleware Trait Type Attribute Type <code>optionalQueryParam</code> <code>QueryParam Optional Strict name val</code> or <code>OptionalQueryParam name val</code> <code>Maybe val</code> <code>lenientQueryParam</code> <code>QueryParam Required Lenient name val</code> <code>Either Text val</code> <code>optionalLenientQueryParam</code> <code>QueryParam Optional Lenient name val</code> <code>Maybe (Either Text val)</code> <p>Their usage is very similar to <code>queryParam</code>. The <code>Optional</code> variants can be used when the query parameter is not mandatory and the <code>Lenient</code> variants can be used when you don't want to fail in case of parsing errors. Note that the trait and attribute types change accordingly.</p>"},{"location":"tutorial/request-handling/request-traits/#headers","title":"Headers","text":"<p>Request headers can be accessed very similar to query parameters in WebGear. These are the middlewares and associated types for request headers:</p> Middleware Trait Type Attribute Type <code>header</code> <code>RequestHeader Required Strict name val</code> or <code>RequiredRequestHeader name val</code> <code>Maybe val</code> <code>optionalHeader</code> <code>RequestHeader Optional Strict name val</code> or <code>OptionalRequestHeader name val</code> <code>Maybe val</code> <code>lenientHeader</code> <code>RequestHeader Required Lenient name val</code> <code>Either Text val</code> <code>optionalLenientHeader</code> <code>RequestHeader Optional Lenient name val</code> <code>Maybe (Either Text val)</code> <p>Since they are very similar to query parameters, we'll omit an example here. You may refer to the API documentation for more details.</p>"},{"location":"tutorial/request-handling/request-traits/#cookies","title":"Cookies","text":"<p>There are two middlewares for access request cookies:</p> Middleware Trait Type Attribute Type <code>cookie</code> <code>Cookie Required name val</code> <code>val</code> <code>optionalCookie</code> <code>Cookie Optional name val</code> <code>Maybe val</code> <p>As you've probably guessed, the former is used in case of mandatory cookies and the latter in case of optional cookies.</p> <p>As an example, the code below accesses a mandatory cookie named <code>session-id</code> from the request.</p> <pre><code>sessionHandler :: (StdHandler h m, Get h (Cookie Required \"session-id\" Text)) =&gt; RequestHandler h ts\nsessionHandler =\n  cookie @\"session-id\" @Text errorHandler $\n    proc request -&gt; do\n      let sessionId = pick @(Cookie Required \"session-id\" Text) $ from request\n      respondA HTTP.ok200 PlainText -&lt; \"Session ID: \" &lt;&gt; sessionId\n</code></pre> <p>But this raises a compilation error:</p> <pre><code>\u2022 Could not deduce \u2018HasTrait\n                       (RequestHeader Required Strict \"Cookie\" Text) ts\u2019\n    arising from a use of \u2018cookie\u2019\n  from the context: (StdHandler h m,\n                     Get h (Cookie Required \"session-id\" Text))\n</code></pre> <p>This is because extracting a cookie is a two step process. First, you need to get the <code>Cookie</code> header from the request and then extract a cookie from the header value. WebGear models such dependencies using trait prerequisites. In this case, the <code>RequestHeader Required Strict \"Cookie\" Text</code> trait is a prerequisite for the <code>Cookie Required\"session-id\" Text</code> trait.</p> <p>To satisfy the prerequisite, we make a couple of changes:</p> <pre><code>sessionHandler ::\n  ( StdHandler h m\n  , Gets h [RequiredRequestHeader \"Cookie\" Text, Cookie Required \"session-id\" Text]\n  ) =&gt; RequestHandler h ts\nsessionHandler =\n  header @\"Cookie\" @Text errorHandler $\n    cookie @\"session-id\" @Text errorHandler $\n      proc request -&gt; do\n        let sessionId = pick @(Cookie Required \"session-id\" Text) $ from request\n        respondA HTTP.ok200 PlainText -&lt; \"Session ID: \" &lt;&gt; sessionId\n</code></pre> <p>The <code>header @\"Cookie\" @Text</code> middleware will satisfy the prerequisite. But you also need to add a <code>Get</code> constraint for this new trait to the type signature. In this case, we used the <code>Gets</code> constraint which supports a list of traits. This is a concise form as compared to adding one constraint for each trait.</p>"},{"location":"tutorial/request-handling/request-traits/#request-body","title":"Request Body","text":"<p>The <code>requestBody</code> middleware is used to extract the HTTP body from a request as a Haskell value. It accepts two arguments - a MIME type that determines how the body is converted to the Haskell value and an error handler for processing errors.</p> <p>As an example, let us look at how to parse a JSON formatted request body into a Haskell type:</p> <pre><code>data MyRecord = MyRecord\n  { -- some JSON fields go here\n  }\n  deriving stock (Generic, Show)\n  deriving anyclass (FromJSON)\n\njsonBodyHandler :: (StdHandler h m, Get h (Body JSON MyRecord)) =&gt; RequestHandler h ts\njsonBodyHandler =\n  requestBody @MyRecord JSON errorHandler $\n    proc request -&gt; do\n      let record :: MyRecord = pick @(Body JSON MyRecord) $ from request\n      ....\n</code></pre> <p>WebGear includes more MIME types apart from <code>JSON</code>. These are defined in the <code>WebGear.Core.MIMETypes</code> module:</p> <ul> <li><code>HTML</code> - The <code>text/html</code> MIME type</li> <li><code>PlainText</code> - The <code>text/plain</code> MIME type</li> <li><code>OctetStream</code> - The <code>application/octet-stream</code> MIME type</li> <li><code>FormURLEncoded</code> - The <code>application/x-www-form-urlencoded</code> MIME type</li> <li><code>FormData</code> - The <code>multipart/form-data</code> MIME type</li> </ul> <p>Parsing the HTTP body to a Haskell value is defined through the <code>BodyUnrender</code> type class defined in the <code>WebGear.Server.MIMETypes</code> module. Instances of this type class includes the logic to parse the body according to the rules of the MIME type.</p>"},{"location":"tutorial/request-handling/request-traits/#summary","title":"Summary","text":"<p>In this chapter, you learned about the commonly used traits and middlewares to extract information from requests. You may find more information about these in their API documentation.</p> <p>The traits and middlewares included in WebGear are sufficient for most common tasks. If you encounter a use case which is not covered by these traits, it is possible to implement your own traits to handle such cases. We will explore this in a subsequent chapter.</p>"},{"location":"tutorial/request-handling/routing/","title":"Request Routing","text":"<p>In the previous chapter, we briefly touched upon request routing. It is time to explore it in more detail.</p> <p>Routing is how an HTTP request is dispatched to an appropriate request handler. WebGear supports routing based on the request method and/or the request URL path. Let us look at some examples.</p>"},{"location":"tutorial/request-handling/routing/#basic-routing","title":"Basic Routing","text":"<p>You may use the template haskell quasiquoter <code>route</code> to dispatch a request to a handler based on the URL path. For e.g., <code>[route| /api/time |] timeHandler</code> will dispatch the request to <code>timeHandler</code> if the request path is <code>/api/time</code>.</p> <p>You may further restrict the routing, by specifying an HTTP method in addition to the path.</p> <pre><code>import qualified Network.HTTP.Types as HTTP\n...\n[route| HTTP.GET /api/time |] timeHandler\n</code></pre> <p>The above code routes the request to <code>timeHandler</code> only if both the request method and the path matches.</p> <p>Note</p> <p>We haven't implemented <code>timeHandler</code> yet and that is intentional. This chapter focuses on routing and we'll not pay much attention to implementing request handlers at this point. For now, you may assume that handlers are arrows that takes a request as input and produces a response as output - just like the hello world example from the previous chapter.</p>"},{"location":"tutorial/request-handling/routing/#capturing-path-variables","title":"Capturing Path Variables","text":"<p>In many cases, you may want to treat some parts of the path as a variable to be captured for processing later in the handler. For example, the below code can be used to retrieve users based on their id.</p> <pre><code>import WebGear.Core\nimport WebGear.Server\nimport qualified Network.HTTP.Types as HTTP\nimport qualified Network.Wai as Wai\n\nuserApp :: Wai.Application\nuserApp = toApplication $\n  [route| HTTP.GET /api/user/userId:Int |] getUser\n</code></pre> <p>Here, <code>userId</code> is a path variable label that captures an value of type <code>Int</code>. The captured variable value can be accessed by the <code>getUser</code> handler. We'll see how to do that in the next chapter.</p> <p>You can use any type for the captured variable, provided it has an instance of <code>FromHttpApiData</code> type class. For example, you can modify the above code to use a custom <code>UserId</code> type:</p> <pre><code>import Web.HttpApiData (FromHttpApiData)\n\nnewtype UserId = UserId Int\n  deriving newtype (FromHttpApiData)\n\nuserApp :: Wai.Application\nuserApp = toApplication $\n  [route| HTTP.GET /api/user/userId:UserId |] getUser\n</code></pre>"},{"location":"tutorial/request-handling/routing/#multiple-endpoints","title":"Multiple Endpoints","text":"<p>A typical application will have multiple API endpoints and WebGear supports this using the <code>ArrowPlus</code> typeclass.</p> <p>Here is an example. If you want two APIs, one to retrieve a user and another to retrieve a book, both can be combined using the <code>&lt;+&gt;</code> operation to form a single application.</p> <pre><code>myApp :: Wai.Application\nmyApp = toApplication $ userAPI &lt;+&gt; bookAPI\n  where\n    userAPI = [route| HTTP.GET /api/user/userId:Int |] getUser\n    bookAPI = [route| HTTP.GET /api/book/bookId:Int |] getBook\n</code></pre> <p>WebGear will try to route the request in the specified order - first to the user API and then the book API. The request will be dispatched to the route that matches first. If none of the routes match, a 404 (not found) response will be returned.</p>"},{"location":"tutorial/request-handling/routing/#path-prefix-matching","title":"Path-prefix Matching","text":"<p>In the example above, both the APIs had something in common; they use the <code>GET</code> method and have a path prefix of <code>/api</code>. We had to repeat these on both the handlers and that's not ideal. Fortunately, we do not need to do that.</p> <p>There is another quasiquoter - <code>match</code> - that captures a prefix of the path. Let us use it to capture the common parts of the APIs and then the <code>route</code> quasiquoter to capture the rest as shown below.</p> <pre><code>myApp :: Wai.Application\nmyApp = toApplication $\n  [match| HTTP.GET /api |] $ userAPI &lt;+&gt; bookAPI\n  where\n    userAPI = [route| /user/userId:Int |] getUser\n    bookAPI = [route| /book/bookId:Int |] getBook\n</code></pre>"},{"location":"tutorial/request-handling/routing/#eliminate-the-quasiquoter","title":"Eliminate the Quasiquoter","text":"<p>While the quasiquoters are very convenient, not everyone likes them. They feel somewhat magicical and require a language extension. The good news is that you do not have to use them if you don't want to. The <code>route</code> and <code>match</code> quasiquoters are implemented using four functions described below. You may use them instead of <code>route</code> and <code>match</code>.</p> <p>The first function is <code>method</code>. It inspects the HTTP method of the request and dispatches the request to a specified handler in case of a match.</p> <pre><code>method HTTP.POST postHandler\n</code></pre> <p>This invokes <code>postHandler</code> only if the request method is <code>POST</code>.</p> <p>The second function is <code>path</code>. It attempts to match a prefix of the request path and dispatches the request to a handler in case of a match.</p> <pre><code>path \"/api\" apiHandler\n</code></pre> <p>This invokes apiHandler when the request path begins with <code>/api</code>.</p> <p>The third function is <code>pathVar</code>. Use it to capture a segment of the request path as a path variable.</p> <pre><code>pathVar @\"userId\" @Int userHandler\n</code></pre> <p>This attempts to parse the next segment of the path as an <code>Int</code> and assign the value to a path variable labelled <code>userId</code>. If that succeeds, <code>userHandler</code> will be invoked.</p> <p>Finally, we have <code>pathEnd</code>. This function validates that there are no more segments in the request path and invokes a handler in that case.</p> <pre><code>pathEnd nextHandler\n</code></pre> <p>You can chain these functions in any order you want to route the requests. For example:</p> <pre><code>method HTTP.GET $ path \"/api/user\" $ pathVar @\"userId\" @Int $ pathEnd userHandler\n</code></pre> <p>This invokes <code>userHandler</code> when the request method is <code>GET</code>, the path is of the format <code>/api/user/&lt;userId&gt;</code>, and the <code>&lt;userId&gt;</code> portion of the path can be parsed as an <code>Int</code>.</p> <p>The <code>myApp</code> API from the previous example can be rewritten as:</p> <pre><code>myApp :: Wai.Application\nmyApp = toApplication $\n  method HTTP.GET $ path \"/api\" $ userAPI &lt;+&gt; bookAPI\n  where\n    userAPI = path \"/user\" $ pathVar @\"userId\" @Int $ pathEnd getUser\n    bookAPI = path \"/book\" $ pathVar @\"bookId\" @Int $ pathEnd getBook\n</code></pre> <p>This version does not use any quasiquoters, but is more verbose. In fact, the quasiquoter generates the above code. It is up to you to choose the version you prefer.</p>"},{"location":"tutorial/request-handling/routing/#summary","title":"Summary","text":"<p>In this chapter, you learned how to route requests to handlers based on the request method and path. You also learned to implement routing with template haskell quasiquoters and regular functions.</p> <p>Out-of-the-box, WebGear only supports routing based on request method and path. However, you can easily implement routing based on any other criteria. This is covered in the reference guide in detail.</p>"}]}